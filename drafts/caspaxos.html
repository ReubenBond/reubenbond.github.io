
<!DOCTYPE html>
<html lang="en">
        <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge"/>

        <title>reublog - Why I&#x27;m excited about CASPaxos</title>
        <meta name="description" content="Linearizable databases without logs" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0">        

        <link type="application/rss+xml" rel="alternate" title="reublog" href="/feed.rss" />
                <link type="application/atom+xml" rel="alternate" title="reublog" href="/feed.atom" />
        <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
        <link rel="icon" href="/favicon.ico" type="image/x-icon">

        <link href="/assets/css/bootstrap.min.css" rel="stylesheet" />
        <link href="/assets/css/highlight.css" rel="stylesheet">
        <link href="/assets/css/clean-blog.css" rel="stylesheet" />
        <link href="/assets/css/master.css" rel="stylesheet" />
        <link href="/assets/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>
        <link href="/assets/css/override.css" rel="stylesheet" />


        <meta name="application-name" content="reublog" />
        <meta name="msapplication-tooltip" content="reublog - Why I&#x27;m excited about CASPaxos" />
        <meta name="msapplication-starturl" content="/" />

        <meta property="og:title" content="Why I&#x27;m excited about CASPaxos" />
        <meta property="og:image" content="http://reubenbond.github.io/images/caspaxos-banner.png" />
        <meta property="og:type" content="website" />
        <meta property="og:url" content="http://reubenbond.github.io/drafts/caspaxos" />
        <meta property="og:description" content="Linearizable databases without logs" />
        <meta property="article:published_time" content="2018-03-19T00:00:00.0000000" />
                <meta property="article:tag" content="CASPaxos" />
        <meta property="article:tag" content="Distributed Consensus" />
        <meta property="article:tag" content="Orleans" />

        <meta name="twitter:card" content="summary" />
        <meta name="twitter:site" content="@ReubenBond" />

        <script src="/assets/js/jquery.min.js"></script>
        <script src="/assets/js/bootstrap.min.js"></script>     
        <script src="/assets/js/highlight.pack.js"></script>   
        <script src="/assets/js/clean-blog.js"></script>
        <script src="/assets/js/d3.v3.min.js"></script>
        <script src="/assets/js/trianglify.min.js"></script>
        <script src="/assets/js/Please-compressed.js"></script>
        <script src="/assets/js/background-check.min.js"></script>
                
        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
                <script src="/assets/js/html5shiv.js"></script>
                <script src="/assets/js/respond.min.js"></script>
        <![endif]-->
        
        


        </head>
        <body>
                
                <!-- Navigation -->
                <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
                        <div class="container-fluid">
                                <!-- Brand and toggle get grouped for better mobile display -->
                                <div class="navbar-header page-scroll">
                                        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar-collapse">
                                        <span class="sr-only">Toggle navigation</span>
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                        <span class="icon-bar"></span>
                                        </button>
                                        <a class="navbar-brand" href="/">reublog</a>
                                </div>
                        
                                <!-- Collect the nav links, forms, and other content for toggling -->
                                <div class="collapse navbar-collapse" id="navbar-collapse">
                                        <ul class="nav navbar-nav navbar-right">
                                                    <li><a href="https://twitter.com/ReubenBond">Twitter: @ReubenBond</a></li>
 
                                                    <div class="follow-button">
                                        </ul>
                                </div>
                                <!-- /.navbar-collapse -->
                        </div>
                        <!-- /.container -->
                </nav>
                
                <!-- Page Header -->
                <header class="intro-header" id="intro-header" style="background-image: url(&quot;/images/caspaxos-banner.png&quot;)">
                        <div class="container">
                                <div class="row">
                                        <div class="col-md-12">
<div class="site-heading">
    <h1>Why I&#x27;m excited about CASPaxos</h1>
</div>                                            </div>
                                </div>
                        </div>
                </header>
                
                <!-- Main Content -->
                <div class="container">
                        <div class="row">
                                <div id="content" class="col-md-12">
                                        <p>Recently I've been playing around with a new algorithm known as <a href="https://arxiv.org/abs/1802.07000">CASPaxos</a>. In this post I'm going to talk about the algorithm and its potential benefits for distributed databases, particularly key-value stores.</p>
<p>Distributed databases must be <strong>reliable</strong> and <strong>scalable</strong>. To achieve reliability, DBs replicate data to other servers. To achieve scalability in terms of total storage capacity, DBs must allow the data to be replicated to only a subset of servers - enough to make the data reasonably reliable but not so much that adding a new server does not increase the total storage capacity of the system or make the system unbearably slow. A typical replication factor is 3: each piece of data is stored on 3 servers. Replications is typically implemented using a consensus algorithm. Well-known algorithms in this family that are used for replication are Raft, Multi-Paxos, and ZAB (which is used in ZooKeeper). Those 3 algorithms make servers agree on the ordering of operations in a log. By executing those operations in order, the database engines on each server can create identical replicas of a database. Logs feature very prominently in distributed/reliable systems (Read <em><a href="https://engineering.linkedin.com/distributed-systems/log-what-every-software-engineer-should-know-about-real-time-datas-unifying">The Log: What every software engineer should know about real-time data's unifying abstraction</a></em> by Jay Kreps).</p>
<p><a href="https://arxiv.org/abs/1802.07000">CASPaxos</a> is a new algorithm in this space and it is significantly simpler than the aforementioned algorithms because it does not use log replication. It is a slight modification of the original Paxos algorithm, which is very simple and typically used as a minimal building block for more complicated algorithms such as Multi-Paxos. Instead of replicating log entries between servers, CASPaxos replicates entire values. Because of this, it is best suited for relatively small values, such as individual entries in a key-value store.</p>
<p>So why is this interesting? In short: it offers us simplicity &amp; performance.</p>
<h2 id="simplicity">Simplicity</h2>
<p>The canonical implementation of CASPaxos by its author <a href="https://twitter.com/rystsov">Denis Rystsov (&#64;rystsov)</a> is <a href="https://github.com/gryadka/js">Gryadka</a>, a key-value store written in JavaScript which sits atop Redis. The core, including the CASPaxos implementation, has less than 500 lines of code. <a href="https://raft.github.io/">Raft</a> was also designed to be a simple and understandable algorithm, but it carries with it the weight of log replication, which brings with it the need for log compaction, which brings with it the need for snapshotting and snapshot transfer. Raft also requires leadership elections because it is built around the concept of a &quot;strong leader&quot;. All writes must be served by the single master in a Raft system, whereas writes can be served by any replica in a CASPaxos system. CASPaxos is simpler to implement than Raft. The <a href="https://raft.github.io/raft.pdf">extended Raft paper</a> is a great read. <a href="https://github.com/ongardie/dissertation#readme">Diego Ongaro's Ph. D dissertation</a> includes an important simplification to the original paper's membership change algorithm. Let's be clear here: Raft definitely achieved its goal of understandability and it truly deserves the widespread adoption it's seen.</p>
<h2 id="storage-performance">Storage Performance</h2>
<p>To analyse the performance implications of CASPaxos, we need to take a little detour and discuss real-world systems. One great example is <a href="https://www.cockroachlabs.com/">CockroachDB</a>, a distributed SQL database. CockroachDB aims to be <strong>reliable</strong> and <strong>scalable</strong>. To achieve this, they partition their data and replicate each piece of data to a subset of the servers in the system using an algorithm they call <a href="https://www.cockroachlabs.com/blog/scaling-raft/">MultiRaft</a>. If they were to use a single Raft consensus group, then adding additional servers would not increase the total capacity of the database. If they use many Raft consensus groups naively, the overhead of each consensus group would have a toll on throughput. For example, Raft requires heartbeat messages while idle to maintain leadership. MultiRaft requires multiplexing each consensus group's log records on disk for performance. That means that log entries for each group might not live near each other on disk, since they are interspersed with many other groups' records. This may take a toll on recovery performance. The alternative is to store each group's log in contiguous disk segments, but this reduces write throughput: spinning disks and SSDs both perform better when operating sequentially. The optimizations required to make Raft scale well are tricky largely because of its log-based nature.</p>
<p>Speaking of storage, let's talk briefly about storage engines. The storage engine is the database component responsible for reading and writing data in a reliable way. Examples include RocksDB, LMDB, ESENT (used in Exchange &amp; Active Directory), WiredTiger, TokuDB, and InnoDB. Two of the most common data structures for implementing a storage engine are <a href="https://en.wikipedia.org/wiki/B%2B_tree">B+ Trees</a> and more recently, <a href="https://en.wikipedia.org/wiki/Log-structured_merge-tree">Log-Structured Merge-Trees</a> (LSM trees). In order to make B+ Trees reliable (any machine may crash at any time), a <a href="https://sqlite.org/wal.html">Write-Ahead Log</a> (WAL) is used. This log is a file containing a sequential list of the database transactions which are being performed. The storage engine eventually applies these transactions to the database image. During crash recovery, the storage engine reads this file and ensures that all of the committed transactions have been applied. This recovery algorithm is called <a href="https://en.wikipedia.org/wiki/Algorithms_for_Recovery_and_Isolation_Exploiting_Semantics">ARIES</a> and it can be found in many reliable storage engines. So B+ Trees split your data into two parts: a log file and a tree. As the name implies, Log-Structured Merge-Trees include a log as a part of the core data structure and again, that log is used for recovery. Since spinning disks and SSDs perform best with sequential reads &amp; writes, log files are a good fit for high-performance, reliable systems.</p>
<p>Raft is built around log replication, so it might make sense to integrate with the storage engine so that a single log can be used for both purposes: local durability as well as replication. Unfortunately, the storage engine's log is generally not visible to the storage engine consumer and is usually considered an implementation detail. This means that Raft implementations which use an off-the-shelf storage engine such as RocksDB must store log records inside the storage engine so that they can be read back later. The result is that each operation needs at least 2 writes (1 on the critical path): one for the log entry and one for the result of applying the log entry once it's committed (eg, updating a value in a key-value store). A B+ Tree engine needs 4 writes (1 critical). By contrast, CASPaxos needs just 1 write: updating the value itself. Log-based algorithms have natural write amplification where as CASPaxos does not.</p>
<p>By removing the need for logs, CASPaxos can achieve high write throughput with off-the-shelf storage engines.</p>
<h2 id="coordination">Coordination</h2>
<p>Each key in a key-value store based on CASPaxos is completely independent of all other keys. This means that no cross-key coordination is required when serving operations on individual keys. Compare this with Raft or MultiRaft where all operations within a given consensus group are strictly ordered. This ordering requires coordination which has some overhead. It means that a slow operation on one key can more easily impact operations on other keys. The low level of coordination required by CASPaxos supports high-concurrency systems without added complexity.</p>
<p>Coordination is sometimes required. For example, when implementation multi-object transactions. Multi-object transactions can be implemented as a higher layer on top of a key-value store with linearizable keys using <a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol">two-phase commit (2PC)</a>. For example, this is how we implement <a href="https://www.microsoft.com/en-us/research/publication/transactions-distributed-actors-cloud-2/">ACID transactions in Orleans</a>, supporting any strong consistency key-value store.</p>
<h1 id="open-questions">Open Questions</h1>
<p>So far we've talked about ways in which CASPaxos might be more suitable for building a distributed key-value store than Raft or MultiRaft. CASPaxos is a simple algorithm and there are many system design questions which are not addressed by the paper definition. So here are some potential pitfalls as well as some thoughts on how to solve them:</p>
<h2 id="server-catch-up">Server Catch-up</h2>
<p>When adding a new server to the database system, the server needs to be brought up to speed with the existing servers. This requires adding it to the consensus group as well as copying all data for the keys which it will be replicating. The CASPaxos paper describes this process as a part of membership change. However, a similar process is needed to ensure that data is sufficiently reliable. For example, if a server loses network connectivity for a few seconds then it may miss some updates to some rarely updated keys. The CASPaxos algorithm does not discuss how to ensure that all updates are eventually replicated. In Raft, it is the leader's responsibility to keep followers up to speed. In a system built around CASPaxos, which is leaderless, we will likely need to implement a different solution.</p>
<h2 id="membership-change">Membership Change</h2>
<p>The membership change algorithm in the paper does not offer safety in all cases and it implies a single administrator in the system. Therefore, it is not suitable for use with automated cluster management systems. The <a href="https://github.com/ReubenBond/orleans/tree/poc-caspaxos/src/Orleans.MetadataStore">proof-of-concept CASPaxos implementation</a> on <a href="https://dotnet.github.io/orleans/Documentation/Introduction.html">Orleans</a>, uses a <a href="https://github.com/ReubenBond/orleans/blob/ad69bcaa21381573a39681dd29cb8f2148adc7d4/src/Orleans.MetadataStore/Configuration/ConfigurationManager.cs#L97">different membership change algorithm</a>. It is suitable for automated systems (such a the <a href="https://dotnet.github.io/orleans/Documentation/Runtime-Implementation-Details/Cluster-Management.html">cluster membership algorithm used in Orleans</a>). I believe it is safe, but that has not been demonstrated yet (maybe I should take Lamport's TLA+ workshop). The key idea is to leverage the consensus mechanism of the protocol for cluster membership change, similar to how Raft and Multi-Paxos commit configuration changes to the log. It uses a special purpose register to store cluster configuration. Proposers indicate which version of the configuration they are using in all calls to Acceptors and Acceptors reject requests from Proposers running old configurations. This is similar to Raft's notion of neutralizing old leaders. Additionally membership changes are restricted to at-most one server at a time, which is a special case of <em>joint consensus</em>. This the same restriction that Diego Ongaro specified in <a href="https://github.com/ongardie/dissertation#readme">his Ph. D dissertation</a> for Raft. In a sense, this extension turns CASPaxos into a 2-level store with the cluster configuration register at the top and data registers below, so the ballot vector is <code>[configuration ballot, data ballot]</code>.</p>
<h2 id="scale-out">Scale-out</h2>
<p>Adding additional servers should increase the total storage capacity of the system. CASPaxos specifies only the minimal building block of a key-value store, so this scale-out is not discussed in the paper. The Raft paper also does not specify this, motivating the development of MultiRaft for CockroachDB. The dynamic range-based partitioning scheme used by CockroachDB is a good candidate. Implementing this might involve storing range configurations in registers and extending the membership change modification to include 3 levels, <code>[cluster ballot, range ballot, data ballot]</code>.</p>
<h2 id="large-values">Large Values</h2>
<p>CASPaxos is not suitable for replicating large values because each value is sent over the wire every time it is updated. For a replication factor of 3, the entire value is sent 3 times for every update and 6 times if the proposer cannot take advantage of the <em>distinguished leader</em> optimization.</p>
<p>This limitation could be alleviated in several ways, or it can be ignored and argued away, leaving users to tackle the problem themselves if they truly need large values.</p>
<p>One way to alleviate it might be to split keys over several registers. Without going into detail, this might involve extending the membership change modification yet again to include 4 levels, at which point it may make sense to generalize it into a <em>ballot vector</em>, <code>[...parent ballots, register ballot]</code>. Specifically, <code>[config ballot, range ballot, file ballot, register ballot]</code>. At this point, the system is structured more like a tree than a flat key-value store.</p>
<h1 id="conclusion">Conclusion</h1>
<p>I hope you've enjoyed the post. If you'd like to discuss any aspects of it, for example some glaring inaccuracies, drop me a line via Twitter (<a href="https://twitter.com/reubenbond">&#64;ReubenBond</a>).</p>
<p>Distributed Systems is a young field with many exciting areas for research and development.</p>

                                </div>
                        </div>
                </div>
                                
                <!-- Footer -->
                <footer>
                        <div class="container">
        <div class="row">
                <div class="col-md-12 text-center">
                    <div>
                        <a href="https://twitter.com/ReubenBond?ref_src=twsrc%5Etfw" class="twitter-follow-button" data-size="large" data-show-count="false">Follow @ReubenBond</a>
                    </div>
                    <p class="copyright text-muted">
                        Copyright © 2018
                        <br />
                            <a href="/feed.rss"><i class="fa fa-rss"></i> RSS Feed</a>
                        |
                            <a href="/feed.atom"><i class="fa fa-rss"></i> Atom Feed</a>
                        <br />
                        <strong><a href="https://wyam.io">Generated by Wyam</a></strong>
                    </p>
                </div>
        </div>
</div>

                </footer> 

                
                <script>hljs.initHighlightingOnLoad();</script>


                <script>
                        BackgroundCheck.init({
                                targets: '.intro-header,.navbar',
                                images: '.intro-header'
                        });
                </script>

                <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

                <!-- Global site tag (gtag.js) - Google Analytics -->
                <script async src="https://www.googletagmanager.com/gtag/js?id=UA-77999682-2"></script>
                <script>
                window.dataLayer = window.dataLayer || [];
                function gtag(){dataLayer.push(arguments);}
                gtag('js', new Date());

                gtag('config', 'UA-77999682-2');
                </script>
        </body>
</html>

