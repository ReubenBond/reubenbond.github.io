<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>reublog</title>
		<link>http://reubenbond.github.io/</link>
		<description>reublog</description>
		<copyright>2019</copyright>
		<pubDate>Tue, 15 Jan 2019 18:00:44 GMT</pubDate>
		<lastBuildDate>Tue, 15 Jan 2019 18:00:44 GMT</lastBuildDate>
		<item>
			<title>Performance Tuning for .NET Core</title>
			<link>http://reubenbond.github.io/posts/dotnet-perf-tuning</link>
			<description>&lt;p&gt;Some of you may know I've been spending whatever time I can scrounge together grinding away at a new serialization library for .NET.
Serializers can be complicated beasts. They have to be reliable, flexible, and fast beyond reproach.
I won't convince you that serialization libraries have to be quick — in this post, that's a given. These are some tips from my experience in optimizing &lt;a href="https://github.com/ReubenBond/Hagar"&gt;Hagar&lt;/a&gt;'s performance. &lt;strong&gt;Most of this advice is applicable to other types of libraries or applications.&lt;/strong&gt;&lt;/p&gt;</description>
			<enclosure url="http://reubenbond.github.io/images/header.jpg" length="0" type="image" />
			<guid>http://reubenbond.github.io/posts/dotnet-perf-tuning</guid>
			<pubDate>Tue, 15 Jan 2019 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;Some of you may know I've been spending whatever time I can scrounge together grinding away at a new serialization library for .NET.
Serializers can be complicated beasts. They have to be reliable, flexible, and fast beyond reproach.
I won't convince you that serialization libraries have to be quick — in this post, that's a given. These are some tips from my experience in optimizing &lt;a href="https://github.com/ReubenBond/Hagar"&gt;Hagar&lt;/a&gt;'s performance. &lt;strong&gt;Most of this advice is applicable to other types of libraries or applications.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A post on performance should have minimal overhead and get straight to the point, so this post focuses on tips to help you and things to look out for. &lt;a href="https://twitter.com/reubenbond"&gt;Message me on Twitter&lt;/a&gt; if something is unclear or you have something to add.&lt;/p&gt;
&lt;h2 id="maximize-profitable-inlining"&gt;Maximize profitable inlining&lt;/h2&gt;
&lt;p&gt;Inlining is the technique where a method body is copied to the call site so that we can avoid the cost of jumping, argument passing, and register saving/restoring. In addition to saving those costs, inlining is a requirement for other optimizations. Roslyn (C#'s compiler) does not inline code. Instead, it is the responsibility of the JIT, as are most optimizations.&lt;/p&gt;
&lt;h3 id="use-static-throw-helpers"&gt;Use static &lt;em&gt;throw helpers&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;A recent change which involved a significant refactor added around 20ns to the call duration for the serialization benchmark, increasing times from ~130ns to ~150ns (which is significant).&lt;/p&gt;
&lt;p&gt;The culprit was the &lt;code&gt;throw&lt;/code&gt; statement added in this helper method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public static Writer&amp;lt;TBufferWriter&amp;gt; CreateWriter&amp;lt;TBufferWriter&amp;gt;(
    this TBufferWriter buffer,
    SerializerSession session) where TBufferWriter : IBufferWriter&amp;lt;byte&amp;gt;
{
    if (session == null) throw new ArgumentNullException(nameof(session));
    return new Writer&amp;lt;TBufferWriter&amp;gt;(buffer, session);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;When a method contains a &lt;code&gt;throw&lt;/code&gt; statement, the JIT will not inline it. The common trick to solve this is to add a static &amp;quot;throw helper&amp;quot; method to do the dirty work for you, so the end result looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static Writer&amp;lt;TBufferWriter&amp;gt; CreateWriter&amp;lt;TBufferWriter&amp;gt;(
    this TBufferWriter buffer,
    SerializerSession session) where TBufferWriter : IBufferWriter&amp;lt;byte&amp;gt;
{
    if (session == null) ThrowSessionNull();
    return new Writer&amp;lt;TBufferWriter&amp;gt;(buffer, session);

    void ThrowSessionNull() =&amp;gt; throw new ArgumentNullException(nameof(session));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Crisis averted. The codebase uses this trick in many places. Having the &lt;code&gt;throw&lt;/code&gt; statement in a separate method may have other benefits such as improving the locality of your commonly used code paths, but I'm unsure and haven't measured the impact.&lt;/p&gt;
&lt;h3 id="minimize-virtualinterface-calls"&gt;Minimize virtual/interface calls&lt;/h3&gt;
&lt;p&gt;Virtual calls are slower than direct calls. If you're writing a performance critical system then there's a good chance you'll see virtual call overhead show up in the profiler. For one, virtual calls require indirection.&lt;/p&gt;
&lt;p&gt;Devirtualization is a feature of many JIT Compilers, and RyuJIT is no exception. It's a complicated feature, though, and there are not many cases where RyuJIT can currently &lt;em&gt;prove&lt;/em&gt; (to itself) that a method can be devirtualized and therefore become a candidate for inlining. Here are a couple of general tips for taking advantage of devirtualization, but I'm sure there are more (so let me know if you have any).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Mark classes as &lt;code&gt;sealed&lt;/code&gt; by default. When a class/method is marked as &lt;code&gt;sealed&lt;/code&gt;, RyuJIT can take that into account and is likely able to inline a method call.&lt;/li&gt;
&lt;li&gt;Mark &lt;code&gt;override&lt;/code&gt; methods as &lt;code&gt;sealed&lt;/code&gt; if possible.&lt;/li&gt;
&lt;li&gt;Use concrete types instead of interfaces. Concrete types give the JIT more information, so it has a better chance of being able to inline your call.&lt;/li&gt;
&lt;li&gt;Instantiate and use non-sealed objects in the same method (rather than having a 'create' method). RyuJIT can devirtualize non-sealed method calls when the type is definitely known, such as immediately after construction.&lt;/li&gt;
&lt;li&gt;Use generic type constraints for polymorphic types so that they can be specialized using a concrete type and interface calls can be devirtualized. In Hagar, our core writer type is defined as follows:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public ref struct Writer&amp;lt;TBufferWriter&amp;gt; where TBufferWriter : IBufferWriter&amp;lt;byte&amp;gt;
{
    private TBufferWriter output;
    // --- etc ---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All calls to methods on &lt;code&gt;output&lt;/code&gt; in the CIL which Roslyn emits will be preceded by a &lt;code&gt;constrained&lt;/code&gt; instruction which tells the JIT that instead of making a virtual/interface call, the call can be made to the precise method defined on &lt;code&gt;TBufferWriter&lt;/code&gt;. This helps with devirtualization. All calls to methods defined on &lt;code&gt;output&lt;/code&gt; are successfully devirtualized as a result. Here's &lt;a href="https://github.com/dotnet/coreclr/issues/9908"&gt;a CoreCLR thread by Andy Ayers&lt;/a&gt; on the JIT team which details current and future work for devirtualization.&lt;/p&gt;
&lt;h2 id="reduce-allocations"&gt;Reduce allocations&lt;/h2&gt;
&lt;p&gt;.NET's garbage collector is a remarkable piece of engineering. GC allows for algorithmic optimizations for some lock-free data structures and also removes whole classes of bugs and lightens the developer's cognitive load. All things considered, garbage collection is a &lt;em&gt;tremendously&lt;/em&gt; successful technique for memory management.&lt;/p&gt;
&lt;p&gt;However, while the GC is a powerful work horse, it helps to lighten its load not only because it means your application will pause for collection less often (and more generally, less CPU time will be devoted to GC work), but also because lightening working set is beneficial for cache locality.&lt;/p&gt;
&lt;p&gt;The rule-of-thumb for allocations is that they should either die in the first generation (Gen0) or live forever in the last (Gen2).&lt;/p&gt;
&lt;p&gt;.NET uses a bump allocator where each thread allocates objects from its per-thread context by 'bumping' a pointer. For this reason, better cache locality can be achieved for short-lived allocations when they are allocated and used on the same thread.&lt;/p&gt;
&lt;p&gt;For more info on .NET's GC, see &lt;a href="https://twitter.com/matthewwarren"&gt;Matt Warren&lt;/a&gt;'s blog post series, &lt;a href="http://mattwarren.org/2016/02/04/learning-how-garbage-collectors-work-part-1/"&gt;&lt;em&gt;Learning How Garbage Collectors Work&lt;/em&gt;&lt;/a&gt; here and pre-order &lt;a href="https://twitter.com/konradkokosa"&gt;Konrad Kokosa&lt;/a&gt;'s book, &lt;a href="https://prodotnetmemory.com/"&gt;&lt;em&gt;Pro .NET Memory Management&lt;/em&gt;  here&lt;/a&gt;. Also check out his fantastic free &lt;a href="https://prodotnetmemory.com/data/netmemoryposter.pdf"&gt;.NET memory management poster here&lt;/a&gt;, it's a great reference.&lt;/p&gt;
&lt;h3 id="pool-buffersobjects"&gt;Pool buffers/objects&lt;/h3&gt;
&lt;p&gt;Hagar itself doesn't manage buffers but instead defers the responsibility to the user. This might sound onerous but it's not, since it's compatible with &lt;a href="https://blogs.msdn.microsoft.com/dotnet/2018/07/09/system-io-pipelines-high-performance-io-in-net/"&gt;&lt;code&gt;System.IO.Pipelines&lt;/code&gt;&lt;/a&gt;. Therefore, we can take advantage of the high performance buffer pooling which the default &lt;code&gt;Pipe&lt;/code&gt; provides by means of &lt;code&gt;System.Buffers.ArrayPool&amp;lt;T&amp;gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Generally speaking, reusing buffers lets you put much less pressure on the GC - your users will be thankful. Don't write your own buffer pool, unless you truly need to, though - those times have passed.&lt;/p&gt;
&lt;h3 id="avoid-boxing"&gt;Avoid boxing&lt;/h3&gt;
&lt;p&gt;Wherever possible, do not box value types by casting them to a reference type. This is common advice, but it requires some consideration in your API design. In Hagar, interface and method definitions which might accept value types are made generic so that they can be specialized to the precise type and avoid boxing/unboxing costs. As a result, there is no hot-path boxing. Boxing is still present in some cases, such as string formatting for exception methods. Those particular boxing allocations can be removed by explicit &lt;code&gt;.ToString()&lt;/code&gt; calls on the arguments.&lt;/p&gt;
&lt;h3 id="reduce-closure-allocations"&gt;Reduce closure allocations&lt;/h3&gt;
&lt;p&gt;Allocate closures only once and store the result for repeated use. For example, it's common to pass a delegate to &lt;code&gt;ConcurrentDictionary&amp;lt;K, V&amp;gt;.GetOrAdd&lt;/code&gt;. Instead of writing the delegate as an inline lambda, define is as a private field on the class. Here an example from the optional &lt;code&gt;ISerializable&lt;/code&gt; support package in Hagar:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;private readonly Func&amp;lt;Type, Action&amp;lt;object, SerializationInfo, StreamingContext&amp;gt;&amp;gt; createConstructorDelegate;

public ObjectSerializer(SerializationConstructorFactory constructorFactory)
{
    // Other parameters/statements omitted.
    this.createConstructorDelegate = constructorFactory.GetSerializationConstructorDelegate;
}

// Later, on a hot code path:
var constructor = this.constructors.GetOrAdd(info.ObjectType, this.createConstructorDelegate);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="minimize-copying"&gt;Minimize copying&lt;/h2&gt;
&lt;p&gt;.NET Core 2.0 and 2.1 and recent C# versions have made considerable strides in allowing library developers to eliminate data copying. The most notable addition is &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt;, but it's also worth mentioning &lt;code&gt;in&lt;/code&gt; parameter modifiers and &lt;code&gt;readonly struct&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="use-spant-to-avoid-array-allocations-and-avoid-data-copying"&gt;Use &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; to avoid array allocations and avoid data copying&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; and friends are a gigantic performance win for .NET, particularly .NET Core where they use an optimized representation to reduce their size, which required adding GC support for interior pointers. Interior pointers are managed references which point to within the bounds of an array, as opposed to only being able to point to the first element and therefore requiring an additional field containing an offset into the array. For more info on &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; and friends, read Stephen Toub's article, &lt;a href="https://msdn.microsoft.com/en-us/magazine/mt814808.aspx"&gt;&lt;em&gt;All About Span: Exploring a New .NET Mainstay&lt;/em&gt; here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Hagar makes extensive use of &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; because it allows us to cheaply create views over small sections of larger buffers to work with. Enough has been written on the subject that there's no use me writing more here.&lt;/p&gt;
&lt;h3 id="pass-structs-by-ref-to-minimize-on-stack-copies"&gt;Pass structs by &lt;code&gt;ref&lt;/code&gt; to minimize on-stack copies&lt;/h3&gt;
&lt;p&gt;Hagar uses two main structs, &lt;code&gt;Reader&lt;/code&gt; &amp;amp; &lt;code&gt;Writer&amp;lt;TOutputBuffer&amp;gt;&lt;/code&gt;. These structs each contain several fields and are passed to almost every call along the serialization/deserialization call path.&lt;/p&gt;
&lt;p&gt;Without intervention, each method call made with these structs would carry significant weight since the entire struct would need to be copied onto the stack for every call, not to mention any mutations would need to be copied back to the caller.&lt;/p&gt;
&lt;p&gt;We can avoid that cost by passing these structs as &lt;code&gt;ref&lt;/code&gt; parameters. C# also supports using &lt;code&gt;ref this&lt;/code&gt; as the target for an extension method, which is very convenient. As far as I know, there's no way to ensure that a particular struct type is always passed by ref and this can lead to subtle bugs if you accidentally omit &lt;code&gt;ref&lt;/code&gt; in the parameter list of a call, since the struct will be silently copied and modifications made by a method (eg, advancing a write pointer) will be lost.&lt;/p&gt;
&lt;h3 id="avoid-defensive-copies"&gt;Avoid defensive copies&lt;/h3&gt;
&lt;p&gt;Roslyn has to do some work to guarantee some language invariants sometimes. When a &lt;code&gt;struct&lt;/code&gt; is stored in a &lt;code&gt;readonly&lt;/code&gt; field, the compiler will insert instructions to &lt;em&gt;defensively copy&lt;/em&gt; that field before involving it in any operation which isn't guaranteed to &lt;em&gt;not&lt;/em&gt; mutate it. Typically this means calls to method defined on the struct type itself because passing a struct as argument to a method defined on another type already requires copying the struct onto the stack (unless it's passed by &lt;code&gt;ref&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;This defensive copy can be avoided if the struct is defined as a &lt;code&gt;readonly struct&lt;/code&gt;, which is a C# 7.2 language feature, enabled by adding &lt;code&gt;&amp;lt;LangVersion&amp;gt;7.2&amp;lt;/LangVersion&amp;gt;&lt;/code&gt; to your csproj file.&lt;/p&gt;
&lt;p&gt;Sometimes it's better to omit the &lt;code&gt;readonly&lt;/code&gt; modifier on an otherwise immutable struct field if you are unable to define it as a &lt;code&gt;readonly struct&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;See Jon Skeet's NodaTime library as an example. In &lt;a href="https://github.com/nodatime/nodatime/pull/1130"&gt;this PR&lt;/a&gt;, Jon made most structs &lt;code&gt;readonly&lt;/code&gt; and was therefore able to add the &lt;code&gt;readonly&lt;/code&gt; modifier to fields holding those structs without negatively impacting performance.&lt;/p&gt;
&lt;h2 id="reduce-branching-branch-misprediction"&gt;Reduce branching &amp;amp; branch misprediction&lt;/h2&gt;
&lt;p&gt;Modern CPUs rely on having long pipelines of instructions which are processed with some concurrency. This involves the CPU analyzing instructions to determine which ones aren't reliant on previous instructions and also involves guessing which conditional jump statements are going to be taken. In order to do this, the CPU uses a component called the branch predictor which is responsible for guessing which branch will be taken. It typically does this by reading &amp;amp; writing entries in a table, revising its prediction based upon what happened last time the conditional jump was executed.&lt;/p&gt;
&lt;p&gt;When it guesses correctly, this prediction process provides a substantial speedup. When it mispredicts the branch (jump target), however, it needs to throw out all of the work performed in processing instructions after the branch and re-fill the pipeline with instructions from the correct branch before continuing execution.&lt;/p&gt;
&lt;p&gt;The fastest branch is no branch. First try to minimize the number of branches, always measuring whether or not your alternative is faster. When you cannot eliminate a branch, try to minimize misprediction rates. This may involve &lt;a href="https://stackoverflow.com/a/11227902/635314"&gt;using sorted data&lt;/a&gt; or restructuring your code.&lt;/p&gt;
&lt;p&gt;One strategy for eliminating a branch is to replace it with a lookup. Sometimes an algorithm can be made branch-free instead of using conditionals. Sometimes &lt;a href="https://mijailovic.net/2018/06/06/sha256-armv8/"&gt;hardware&lt;/a&gt; &lt;a href="https://blogs.msdn.microsoft.com/dotnet/2018/10/10/using-net-hardware-intrinsics-api-to-accelerate-machine-learning-scenarios/"&gt;intrinsics&lt;/a&gt; can be used to eliminate branching.&lt;/p&gt;
&lt;h1 id="other-miscellaneous-tips"&gt;Other miscellaneous tips&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Avoid LINQ. LINQ is great in application code, but rarely belongs on a hot path in library/framework code. LINQ is difficult for the JIT to optimize (&lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;...) and tends to be allocation-happy.&lt;/li&gt;
&lt;li&gt;Use concrete types instead of interfaces or abstract types. This was mentioned above in the context of inlining, but this has other benefits. Perhaps the most common being that if you are iterating over a &lt;code&gt;List&amp;lt;T&amp;gt;&lt;/code&gt;, it's best to &lt;em&gt;not&lt;/em&gt; cast that list to &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; first (eg, by using LINQ or passing it to a method as an &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; parameter). The reason for this is that enumerating over a list using &lt;code&gt;foreach&lt;/code&gt; uses a non-allocating &lt;code&gt;List&amp;lt;T&amp;gt;.Enumerator&lt;/code&gt; struct, but when it's cast to &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt;, that struct must be boxed to &lt;code&gt;IEnumerator&amp;lt;T&amp;gt;&lt;/code&gt; for &lt;code&gt;foreach&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Reflection is exceptionally useful in library code, but it &lt;em&gt;will&lt;/em&gt; kill you if you give it the chance. Cache the results of reflection, consider generating delegates for accessors using IL or Roslyn, or better yet, use an existing library such as &lt;a href="https://github.com/aspnet/Common/blob/ff87989d893b000aac1bfef0157c92be1f04f714/shared/Microsoft.Extensions.ObjectMethodExecutor.Sources/ObjectMethodExecutor.cs"&gt;&lt;code&gt;Microsoft.Extensions.ObjectMethodExecutor.Sources&lt;/code&gt;&lt;/a&gt;, &lt;a href="https://github.com/aspnet/Common/blob/ff87989d893b000aac1bfef0157c92be1f04f714/shared/Microsoft.Extensions.PropertyHelper.Sources/PropertyHelper.cs"&gt;&lt;code&gt;Microsoft.Extensions.PropertyHelper.Sources&lt;/code&gt;&lt;/a&gt;, or &lt;a href="https://github.com/mgravell/fast-member"&gt;&lt;code&gt;FastMember&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="library-specific-optimizations"&gt;Library-specific optimizations&lt;/h1&gt;
&lt;h2 id="optimize-generated-code"&gt;Optimize generated code&lt;/h2&gt;
&lt;p&gt;Hagar uses Roslyn to generate C# code for the POCOs you want to serialize, and this C# code is included in your project at compile time. There are some optimizations which we can perform on the generated code to make things faster.&lt;/p&gt;
&lt;h3 id="avoid-virtual-calls-by-skipping-codec-lookup-for-well-known-types"&gt;Avoid virtual calls by skipping codec lookup for well-known types&lt;/h3&gt;
&lt;p&gt;When complex objects contain well known fields such as &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;Guid&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt;, the code generator will directly insert calls to the hand-coded codecs for those types instead of calling into the &lt;code&gt;CodecProvider&lt;/code&gt; to retrieve an &lt;code&gt;IFieldCodec&amp;lt;T&amp;gt;&lt;/code&gt; instance for that type. This lets the JIT inline those calls and avoids virtual/interface indirection.&lt;/p&gt;
&lt;h3 id="unimplemented-specialize-generic-types-at-runtime"&gt;(Unimplemented) Specialize generic types at runtime&lt;/h3&gt;
&lt;p&gt;Similar to above, the code generator could generate code which uses specialization at runtime.&lt;/p&gt;
&lt;h2 id="pre-compute-constant-values-to-eliminate-some-branching"&gt;Pre-compute constant values to eliminate some branching&lt;/h2&gt;
&lt;p&gt;During serialization, each field is prefixed with a header – usually a single byte – which tells the deserializer which field was encoded. This field header contains 3 pieces of info: the wire type of the field (fixed-width, length-prefixed, tag-delimited, referenced, etc), the schema type of the field (expected, well-known, previously-defined, encoded) which is used for polymorphism, and dedicates the last 3 bits to encoding the field id (if it's less than 7). In many cases, it's possible to know exactly what this header byte will be at compile time. If a field has a value type, then we know that the runtime type can never differ from the field type and we always know the field id.&lt;/p&gt;
&lt;p&gt;Therefore, we can often save all of the work required to compute the header value and can directly embed it into code as a constant. This saves branching and generally eliminates a lot of IL code.&lt;/p&gt;
&lt;h2 id="choose-appropriate-data-structures"&gt;Choose appropriate data structures&lt;/h2&gt;
&lt;p&gt;One of the big performance disadvantages Hagar has when compared to other serializers such as &lt;a href="https://github.com/mgravell/protobuf-net"&gt;protobuf-net&lt;/a&gt; (in its default configuration?) and &lt;a href="https://github.com/neuecc/MessagePack-CSharp"&gt;MessagePack-CSharp&lt;/a&gt; is that it supports cyclic graphs and therefore must track objects as they're serialized so that object cycles are not lost during deserialization. When this was first implemented, the core data structure was a &lt;code&gt;Dictionary&amp;lt;object, int&amp;gt;&lt;/code&gt;. It was clear in initial benchmarking that reference tracking was a dominating cost. In particular, clearing the dictionary between messages was expensive. By switching to an array of structs instead, the cost of indexing and maintaining the collection is largely eliminated and reference tracking no longer appears in the benchmarks. There is a downside to this: for large object graphs it's likely that this new approach is slower. If that becomes an issue, we can decide to dynamically switch between implementations.&lt;/p&gt;
&lt;h2 id="choose-appropriate-algorithms"&gt;Choose appropriate algorithms&lt;/h2&gt;
&lt;p&gt;Hagar spends a lot of time encoding/decoding variable-length integers, often referred to as varints, in order to reduce the size of the payload (which can be more compact for storage/transport). Many binary serializers use this technique, including &lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#varints"&gt;Protocol Buffers&lt;/a&gt;. Even .NET's BinaryWriter uses this encoding. Here's a &lt;a href="https://github.com/Microsoft/referencesource/blob/60a4f8b853f60a424e36c7bf60f9b5b5f1973ed1/mscorlib/system/io/binarywriter.cs#L414"&gt;snippet from the reference source&lt;/a&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;protected void Write7BitEncodedInt(int value) {
    // Write out an int 7 bits at a time.  The high bit of the byte,
    // when on, tells reader to continue reading more bytes.
    uint v = (uint) value;   // support negative numbers
    while (v &amp;gt;= 0x80) {
        Write((byte) (v | 0x80));
        v &amp;gt;&amp;gt;= 7;
    }
    Write((byte)v);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Looking at this source, I want to point out that &lt;a href="https://developers.google.com/protocol-buffers/docs/encoding#signed-integers"&gt;ZigZag encoding&lt;/a&gt; may be more efficient for signed integers which contain negative values, rather than casting to &lt;code&gt;uint&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;VarInts in these serializers use an algorithm called Little Endian Base-128 or LEB128, which encodes up to 7 bits per byte. It uses the most significant bit of each byte to indicate whether or not another byte follows (1 = yes, 0 = no). This is a simple format but it may not be the fastest. It might turn out that PrefixVarint is faster. With PrefixVarint, all of those 1s from LEB128 are written in one shot, at the beginning of the payload. This may let us use &lt;a href="https://mijailovic.net/2018/06/06/sha256-armv8/"&gt;hardware&lt;/a&gt; &lt;a href="https://blogs.msdn.microsoft.com/dotnet/2018/10/10/using-net-hardware-intrinsics-api-to-accelerate-machine-learning-scenarios/"&gt;intrinsics&lt;/a&gt; to improve the speed of this encoding &amp;amp; decoding. By moving the size information to the front, we may also be able to read more bytes at a time from the payload, reducing internal bookkeeping and improving performance. If someone wants to implement this in C#, I will happily take a PR if it turns out to be faster.&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Hopefully you've found something useful in this post. &lt;a href="https://twitter.com/reubenbond"&gt;Let me know&lt;/a&gt; if something is unclear or you have something to add. Since I started writing this, I've moved to Redmond and officially joined Microsoft on the &lt;a href="https://github.com/dotnet/orleans"&gt;Orleans&lt;/a&gt; team, working on some very exciting things.&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>.NET IL Generation - Writing DeepCopy</title>
			<link>http://reubenbond.github.io/posts/codegen-2-il-boogaloo</link>
			<description>&lt;p&gt;&lt;em&gt;This is the second part in a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;</description>
			<enclosure url="http://reubenbond.github.io/images/codegen-2-banner.png" length="0" type="image" />
			<guid>http://reubenbond.github.io/posts/codegen-2-il-boogaloo</guid>
			<pubDate>Sat, 04 Nov 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;&lt;em&gt;This is the second part in a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="il-generation"&gt;IL Generation&lt;/h3&gt;
&lt;p&gt;&lt;a href="/posts/codegen-1"&gt;Last time&lt;/a&gt;, we skimmed over some methods to generate code on .NET and one of them was emitting IL. IL generation lets us circumvent the rules C# and other languages put in place to protect us from our own stupidity. Without those rules, we can implement all kinds of fancy foot guns. Rules like “don't access private members of foreign types” and “don't modify &lt;code&gt;readonly&lt;/code&gt; fields”. That last one is interesting: C#'s &lt;code&gt;readonly&lt;/code&gt; translates into &lt;code&gt;initonly&lt;/code&gt; on the IL/metadata level so theoretically we shouldn't be able to modify those fields even using IL. As a matter of fact we can, but it comes at a cost: &lt;strong&gt;our IL will no longer be verifiable&lt;/strong&gt;. That means that certain tools will bark at you if you try to write IL code which commits this sin, tools such as &lt;a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/peverify-exe-peverify-tool"&gt;PEVerify&lt;/a&gt; and &lt;a href="https://github.com/dotnet/corert/tree/master/src/ILVerify"&gt;ILVerify&lt;/a&gt;. Verifiable code also has ramifications for &lt;a href="https://docs.microsoft.com/en-us/dotnet/framework/misc/security-transparent-code"&gt;Security-Transparent Code&lt;/a&gt;. Thankfully for us, Code Access Security and Security Transparent Code &lt;a href="https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/porting.md#code-access-security-cas"&gt;don't exist in .NET Core&lt;/a&gt; and they usually don't cause issue for .NET Framework.&lt;/p&gt;
&lt;p&gt;Enough stalling, onto our mission briefing.&lt;/p&gt;
&lt;h3 id="deepcopy"&gt;DeepCopy&lt;/h3&gt;
&lt;p&gt;Today we're going to implement the guts of a library for creating deep copies of objects. Essentially it provides one method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public static T Copy&amp;lt;T&amp;gt;(T original);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our library will be called &lt;em&gt;DeepCopy&lt;/em&gt; and the source is up on GitHub at &lt;a href="https://github.com/ReubenBond/DeepCopy"&gt;ReubenBond/DeepCopy&lt;/a&gt; feel free to mess about with it. The majority of the code was adapted from the &lt;a href="https://github.com/dotnet/orleans"&gt;Orleans&lt;/a&gt; codebase.&lt;/p&gt;
&lt;p&gt;Deep copying is important for frameworks such as &lt;a href="https://github.com/dotnet/orleans"&gt;Orleans&lt;/a&gt;, since it allows us to safely send mutable objects between grains on the same node without having to first serialize &amp;amp; then deserialze them, among other things. Of course, immutable objects (such as strings) are shared without copying. Oddly enough, serializing then deserializing an object is the &lt;a href="https://stackoverflow.com/a/78612/635314"&gt;accepted Stack Overflow answer&lt;/a&gt; to the question of “how can I deep copy an object?”.&lt;/p&gt;
&lt;p&gt;Let's see if we can fix that.&lt;/p&gt;
&lt;h3 id="battle-plan"&gt;Battle Plan&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;Copy&lt;/code&gt; method will recursively copy every field in the input object into a new instance of the same type. It must be able to deal with multiple references to the same object, so that if the user provides an object which contains a reference to itself then the result will also contain a reference to itself. That means we'll need to perform reference tracking. That's easy to do: we maintain a &lt;code&gt;Dictionary&amp;lt;object, object&amp;gt;&lt;/code&gt; which maps from original object to copy object. Our main &lt;code&gt;Copy&amp;lt;T&amp;gt;(T orig)&lt;/code&gt; method will call into a helper method with that dictionary as a parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public static T Copy&amp;lt;T&amp;gt;(T original, CopyContext context)
{
  /* TODO: implementation */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The copy routine is roughly as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the input is &lt;code&gt;null&lt;/code&gt;, return &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If the input has already been copied (or is currently being copied), return its copy.&lt;/li&gt;
&lt;li&gt;If the input is 'immutable', return the input.&lt;/li&gt;
&lt;li&gt;If the input is an array, copy each element into a new array and return it.&lt;/li&gt;
&lt;li&gt;Create a new instance of the input type and recursively copy each field from the input to the output and return it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our definition of immutable is simple: the type is either a primitive or it's marked using a special &lt;code&gt;[Immutable]&lt;/code&gt; attribute. More elaborate immutability could be probably be soundly implemented, so &lt;a href="https://github.com/ReubenBond/DeepCopy/pull/new/master"&gt;submit a PR&lt;/a&gt; if you've improved upon it.&lt;/p&gt;
&lt;p&gt;Everything but the last step in our routine is simple enough to do without generating code. The last step, recursively copying each field, can be performed using reflection to get and set field values. Reflection is a real performance killer on the hot path, though, and so we're going to go our own route using IL.&lt;/p&gt;
&lt;h3 id="diving-into-the-code"&gt;Diving Into The Code&lt;/h3&gt;
&lt;p&gt;The main IL generation in &lt;em&gt;DeepCopy&lt;/em&gt; occurs inside &lt;a href="https://github.com/ReubenBond/DeepCopy/blob/1b00515b6b6aece93b4bea61bf40780265c2e349/src/DeepCopy/CopierGenerator.cs#L52"&gt;&lt;code&gt;CopierGenerator.cs&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;CreateCopier&amp;lt;T&amp;gt;(Type type)&lt;/code&gt; method. Let's walk through it:&lt;/p&gt;
&lt;p&gt;First we create a new &lt;code&gt;DynamicMethod&lt;/code&gt; which will hold the IL code we emit. We have to tell &lt;code&gt;DynamicMethod&lt;/code&gt; what the signature of the type we're creating is. In our case, it's a generic delegate type, &lt;code&gt;delegate T DeepCopyDelegate&amp;lt;T&amp;gt;(T original, CopyContext context)&lt;/code&gt;. Then we get the &lt;code&gt;ILGenerator&lt;/code&gt; for the method so that we can begin emitting IL code to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;var dynamicMethod = new DynamicMethod(
    type.Name + &amp;quot;DeepCopier&amp;quot;,
    typeof(T), // The return type of the delegate
    new[] {typeof(T), typeof(CopyContext)}, // The parameter types of the delegate.
    typeof(CopierGenerator).Module,
    true);

var il = dynamicMethod.GetILGenerator(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The IL is going to be rather complicated because it needs to deal with immutable types and value types, but let's walk through it bit-by-bit.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// Declare a variable to store the result.
il.DeclareLocal(type);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we need to initialize our new local variable to a new instance of the input type. There are 3 cases to consider, each corresponding to a block in the following code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The type is a value type (struct). Initialize it by essentially using a &lt;code&gt;default(T)&lt;/code&gt; expression.&lt;/li&gt;
&lt;li&gt;The type has a parameterless constructor. Initialize it by calling &lt;code&gt;new T()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The type does not have a parameterless constructor. In this case we ask the framework for help and we call &lt;code&gt;FormatterServices.GetUninitializedObject(type)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// Construct the result.
var constructorInfo = type.GetConstructor(Type.EmptyTypes);
if (type.IsValueType)
{
    // Value types can be initialized directly.
    // C#: result = default(T);
    il.Emit(OpCodes.Ldloca_S, (byte)0);
    il.Emit(OpCodes.Initobj, type);
}
else if (constructorInfo != null)
{
    // If a default constructor exists, use that.
    // C#: result = new T();
    il.Emit(OpCodes.Newobj, constructorInfo);
    il.Emit(OpCodes.Stloc_0);
}
else
{
    // If no default constructor exists, create an instance using GetUninitializedObject
    // C#: result = (T)FormatterServices.GetUninitializedObject(type);
    var field = this.fieldBuilder.GetOrCreateStaticField(type);
    il.Emit(OpCodes.Ldsfld, field);
    il.Emit(OpCodes.Call, this.methodInfos.GetUninitializedObject);
    il.Emit(OpCodes.Castclass, type);
    il.Emit(OpCodes.Stloc_0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="interlude-what-il-should-we-emit"&gt;Interlude - What IL Should We Emit?&lt;/h3&gt;
&lt;p&gt;Even if you're not a first-timer with IL, it's not always easy to work out what IL you need to emit to achieve the desired result. This is where tools come in to help you. Personally I typically write my code in C# first, slap it into &lt;a href="https://www.linqpad.net/"&gt;LINQPad&lt;/a&gt;, hit run and open the IL tab in the output. It's great for experimenting.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/linqpad-il.png" class="img-fluid" alt="LINQPad is seriously handy!" /&gt;&lt;/p&gt;
&lt;p&gt;Another option is to use a decompiler/disassembler like &lt;a href="https://www.jetbrains.com/decompiler/"&gt;JetBrains' dotPeek&lt;/a&gt;. You would compile your assembly and open it in dotPeek to reveal the IL.&lt;/p&gt;
&lt;p&gt;Finally, if you're like me, then &lt;a href="https://www.jetbrains.com/resharper/"&gt;ReSharper&lt;/a&gt; is indispensible. It's like coding on rails (train tracks, not Ruby). ReSharper comes with a convenient &lt;a href="https://www.jetbrains.com/help/resharper/Viewing_Intermediate_Language.html"&gt;IL Viewer&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/resharper-il.png" class="img-fluid" alt="ReSharper IL Viewer" /&gt;&lt;/p&gt;
&lt;p&gt;Alright, so that's how you work out what IL to generate. You'll occasionally want to &lt;a href="https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes(v=vs.110).aspx"&gt;visit the docs&lt;/a&gt;, too.&lt;/p&gt;
&lt;h3 id="back-to-emit"&gt;Back To Emit&lt;/h3&gt;
&lt;p&gt;Now we have a new instance of the input type stored in our local result variable. Before we do anything else, we must record the newly created reference. We push each argument onto the stack in order and use the non-virtual &lt;code&gt;Call&lt;/code&gt; op-code to invoke &lt;code&gt;context.RecordObject(original, result)&lt;/code&gt;. We can use the non-virtual &lt;code&gt;Call&lt;/code&gt; op-code to call &lt;code&gt;CopyContext.RecordObject&lt;/code&gt; because &lt;code&gt;CopyContext&lt;/code&gt; is a &lt;code&gt;sealed&lt;/code&gt; class. If it wasn't, we would use &lt;code&gt;Callvirt&lt;/code&gt; instead.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// An instance of a value types can never appear multiple times in an object graph,
// so only record reference types in the context.
if (!type.IsValueType)
{
    // Record the object.
    // C#: context.RecordObject(original, result);
    il.Emit(OpCodes.Ldarg_1); // context
    il.Emit(OpCodes.Ldarg_0); // original
    il.Emit(OpCodes.Ldloc_0); // result, i.e, the copy of original
    il.Emit(OpCodes.Call, this.methodInfos.RecordObject);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On to the meat of our generator! With the accounting out of the way, we can enumerate over each field and generate code to copy each one into our &lt;code&gt;result&lt;/code&gt; variable. The comments narrate the process:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// Copy each field.
foreach (var field in this.copyPolicy.GetCopyableFields(type))
{
    // Load a reference to the result.
    if (type.IsValueType)
    {
        // Value types need to be loaded by address rather than copied onto the stack.
        il.Emit(OpCodes.Ldloca_S, (byte)0);
    }
    else
    {
        il.Emit(OpCodes.Ldloc_0);
    }

    // Load the field from the result.
    il.Emit(OpCodes.Ldarg_0);
    il.Emit(OpCodes.Ldfld, field);

    // Deep-copy the field if needed, otherwise just leave it as-is.
    if (!this.copyPolicy.IsShallowCopyable(field.FieldType))
    {
        // Copy the field using the generic Copy&amp;lt;T&amp;gt; method.
        // C#: Copy&amp;lt;T&amp;gt;(field)
        il.Emit(OpCodes.Ldarg_1);
        il.Emit(OpCodes.Call, this.methodInfos.CopyInner.MakeGenericMethod(field.FieldType));
    }

    // Store the copy of the field on the result.
    il.Emit(OpCodes.Stfld, field);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return the result and build our delegate using &lt;code&gt;CreateDelegate&lt;/code&gt; so that we can start using it immediately.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// C#: return result;
il.Emit(OpCodes.Ldloc_0);
il.Emit(OpCodes.Ret);
return dynamicMethod.CreateDelegate(typeof(DeepCopyDelegate&amp;lt;T&amp;gt;)) as DeepCopyDelegate&amp;lt;T&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's the guts of the library. Of course many details were left out, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Caching &lt;code&gt;Type&lt;/code&gt; values in static fields so that we can reference them from our generated code. See &lt;a href="https://github.com/ReubenBond/DeepCopy/blob/1b00515b6b6aece93b4bea61bf40780265c2e349/src/DeepCopy/StaticFieldBuilder.cs#L64"&gt;&lt;code&gt;StaticFieldBuilder.cs&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The special handling of arrays in &lt;a href="https://github.com/ReubenBond/DeepCopy/blob/1b00515b6b6aece93b4bea61bf40780265c2e349/src/DeepCopy/DeepCopier.cs#L69"&gt;&lt;code&gt;DeepCopier.cs&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Optimizations such as using &lt;a href="https://github.com/ReubenBond/DeepCopy/blob/master/src/DeepCopy/CachedReadConcurrentDictionary.cs"&gt;&lt;code&gt;CachedReadConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt;&lt;/a&gt; for a slight improvement over &lt;code&gt;ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; for workloads with a diminishing write volume.&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
		</item>
		<item>
			<title>Code Generation on .NET</title>
			<link>http://reubenbond.github.io/posts/codegen-1</link>
			<description>&lt;p&gt;&lt;em&gt;This is the first part in what's hopefully a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;</description>
			<enclosure url="http://reubenbond.github.io/images/codegen-1-banner.png" length="0" type="image" />
			<guid>http://reubenbond.github.io/posts/codegen-1</guid>
			<pubDate>Wed, 01 Nov 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;&lt;em&gt;This is the first part in what's hopefully a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Almost every .NET application relies on code generation in some form, usually because they rely on a library which generates code as a part of how it functions. Eg, Json.NET &lt;a href="https://github.com/JamesNK/Newtonsoft.Json/blob/473a7721bd67cca8fef1ecc37da1951a1c180022/Src/Newtonsoft.Json/Utilities/DynamicReflectionDelegateFactory.cs"&gt;leverages code generation&lt;/a&gt; and so does &lt;a href="https://github.com/aspnet/MvcPrecompilation"&gt;ASP.NET&lt;/a&gt;, Entity Framework, &lt;a href="https://github.com/dotnet/orleans"&gt;Orleans&lt;/a&gt;, most serialization libraries, many dependency injection libraries, and probably every test mocking library.&lt;/p&gt;
&lt;p&gt;Let's skip past &lt;em&gt;why&lt;/em&gt; code generation is useful and jump straight into a high level overview of code generation technologies for .NET.&lt;/p&gt;
&lt;h2 id="kinds-of-code-generation"&gt;Kinds of Code Generation&lt;/h2&gt;
&lt;p&gt;The 3 code gen methods for .NET which we'll discuss are: &lt;strong&gt;Expression Trees&lt;/strong&gt;, &lt;strong&gt;IL Generation&lt;/strong&gt;, and &lt;strong&gt;Syntax Generation&lt;/strong&gt;. There are other methods, such as text templating (eg using T4). Here are the pros and cons of each as I see them.&lt;/p&gt;
&lt;h3 id="expression-trees"&gt;Expression Trees&lt;/h3&gt;
&lt;p&gt;Using &lt;strong&gt;LINQ Expression Trees&lt;/strong&gt; to compile expressions at runtime.&lt;/p&gt;
&lt;p&gt;&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Easy to use, expressive API.&lt;br/&gt;
&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Allows level of access to private members.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Not fully supported on AOT-only platforms like iOS. Expression Trees will be interpreted instead of compiled.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Not all language constructs are supported.&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="il-generation"&gt;IL Generation&lt;/h3&gt;
&lt;p&gt;Using &lt;strong&gt;Reflection.Emit&lt;/strong&gt; to dynamically create types and methods using Common Intermediate Langage (known as CIL or just IL), which is the assembly language of the CLR.&lt;/p&gt;
&lt;p&gt;&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Can produce code which cannot be expressed in C#, eg access private members of some type.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Very verbose.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Very difficult to debug: Visual Studio will not show you IL for dynamic methods, they are represented as an opaque &lt;em&gt;Lightweight Function&lt;/em&gt; entry in the stack trace view.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Difficult to implement higher level features like C#'s &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Not supported on AOT-only platforms like iOS.&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="syntax-generation"&gt;Syntax Generation&lt;/h3&gt;
&lt;p&gt;Using &lt;strong&gt;Roslyn&lt;/strong&gt; or some other API to generate C# syntax trees or source code and compile it either at runtime or when the target project is built.&lt;/p&gt;
&lt;p&gt;&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Easy access to all C# language features.&lt;br/&gt;
&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Supported on AOT-only platforms, since output is C# code which can be compiled.&lt;br/&gt;
&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Well supported: it's the C# compiler, it's not going away or being deprecated any time soon.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; API isn't always obvious since the primary purpose of the API is parsing/compiling code rather than generating it.&lt;br/&gt;
&lt;em&gt;Note:&lt;/em&gt; to support runtime code generationn you need to include Roslyn with your app, which can add around 6MB to your distribution.&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="orleans"&gt;Orleans&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/orleans"&gt;Microsoft Orleans&lt;/a&gt; uses the latter two approaches: IL and Roslyn. It uses Roslyn wherever possible, since it allows for easy access to C# language features like &lt;code&gt;async&lt;/code&gt; and since it's easy to comprehend both the code generator and the generated code. Otherwise, IL generation is used for two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Generating code at runtime. For example &lt;a href="https://github.com/dotnet/orleans/blob/375a98191ca40c27ca8ed61199a6a77a7995e75e/src/Orleans.Core/Serialization/ILSerializerGenerator.cs"&gt;&lt;code&gt;ILSerializerGenerator&lt;/code&gt;&lt;/a&gt; generates serializers as a last resort for types which C# serializers couldn't be generated for (for example, private inner classes). It's a faster and less restricted alternative to .NET's &lt;a href="https://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v=vs.110).aspx"&gt;&lt;code&gt;BinaryFormatter&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Producing code which cannot be expressed in C#. For example, &lt;a href="https://github.com/dotnet/orleans/blob/375a98191ca40c27ca8ed61199a6a77a7995e75e/src/Orleans.Core.Abstractions/Serialization/FieldUtils.cs#"&gt;&lt;code&gt;FieldUtils&lt;/code&gt;&lt;/a&gt; provides access to private fields and methods for serialization.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="general-strategy"&gt;General Strategy&lt;/h2&gt;
&lt;p&gt;Regardless of which technology a library makes use of, code generation typically involves two phases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Metadata Collection
&lt;ul&gt;
&lt;li&gt;The code generator takes some input and creates an abstract representation of it in order to drive the code synthesis process.&lt;/li&gt;
&lt;li&gt;Eg, a library for deeply cloning objects might take a &lt;code&gt;Type&lt;/code&gt; as input and generate an object describing each field in that type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Code Synthesis
&lt;ul&gt;
&lt;li&gt;The code generator uses the metadata model to drive the process of actually generating code (LINQ expressions, IL instructions, syntax tree nodes).&lt;/li&gt;
&lt;li&gt;Eg, our deep cloning library will generate a method which takes an object of the specified type from the metadata model and then recursively copy each of the fields.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The two phases can be merged for simple code generators. Orleans uses two phases. In phase 1, the input assembly is scanned and metadata is collected for types matching various criteria: Grain classes, Grain interfaces, serializable types, and custom serializer registrations. In phase 2, support classes are generated. For example, each grain interface has two classes generated: an RPC proxy and an RPC stub.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;That's enough for now. Maybe next time we'll take a look at writing that hypothetical deep cloning library using IL generation. After that, we can take a look at a serialization library I've been working on which uses Roslyn for both metadata collection and syntax generation. If either of those things are interesting to you, let me know here or on &lt;a href="https://twitter.com/reubenbond"&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="/posts/codegen-2-il-boogaloo"&gt;&lt;strong&gt;Next Post: .NET IL Generation - Writing DeepCopy&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</content:encoded>
		</item>
		<item>
			<title>Deploying Wyam To GitHub Using Visual Studio Online</title>
			<link>http://reubenbond.github.io/posts/-setting-up-wyam</link>
			<description>&lt;p&gt;Here goes nothing! This blog is built with &lt;a href="https://twitter.com/daveaglick"&gt;Dave Glick's&lt;/a&gt; &lt;a href="https://wyam.io/"&gt;Wyam&lt;/a&gt; static site generator and deployed from a git repo in Visual Studio Online to GitHub Pages. Here's how to set up something similar.&lt;/p&gt;</description>
			<enclosure url="http://reubenbond.github.io/images/header.jpg" length="0" type="image" />
			<guid>http://reubenbond.github.io/posts/-setting-up-wyam</guid>
			<pubDate>Tue, 03 Oct 2017 00:00:00 GMT</pubDate>
			<content:encoded>&lt;p&gt;Here goes nothing! This blog is built with &lt;a href="https://twitter.com/daveaglick"&gt;Dave Glick's&lt;/a&gt; &lt;a href="https://wyam.io/"&gt;Wyam&lt;/a&gt; static site generator and deployed from a git repo in Visual Studio Online to GitHub Pages. Here's how to set up something similar.&lt;/p&gt;
&lt;h1 id="prerequisites"&gt;Prerequisites&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;A Visual Studio Online repository for your blog source.
&lt;ul&gt;
&lt;li&gt;You could have also VSO pull the source from GitHub or somewhere else instead, but I haven't covered that here.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A GitHub repository which will serve the compiled output via GitHub Pages.
&lt;ul&gt;
&lt;li&gt;I created a repository called &lt;a href="https://github.com/ReubenBond/reubenbond.github.io"&gt;&lt;code&gt;reubenbond.github.io&lt;/code&gt;&lt;/a&gt; under my profile, &lt;a href="https://github.com/ReubenBond/"&gt;&lt;code&gt;ReubenBond&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cake so you can test it out locally. Install it via &lt;a href="https://chocolatey.org/"&gt;Chocolatey&lt;/a&gt;: &lt;code&gt;choco install cake.portable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="kick-starting-wyam-with-cake"&gt;Kick-starting Wyam with Cake&lt;/h1&gt;
&lt;p&gt;Create a file called &lt;code&gt;build.cake&lt;/code&gt; in the root of your repo with these contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;#tool nuget:?package=Wyam
#addin nuget:?package=Cake.Wyam

var target = Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;);

Task(&amp;quot;Build&amp;quot;)
   .Does(() =&amp;gt;
   {
       Wyam(new WyamSettings
       {
           Recipe = &amp;quot;Blog&amp;quot;,
           Theme = &amp;quot;CleanBlog&amp;quot;,
           UpdatePackages = true
       });
   });
   
Task(&amp;quot;Preview&amp;quot;)
   .Does(() =&amp;gt;
   {
       Wyam(new WyamSettings
       {
           Recipe = &amp;quot;Blog&amp;quot;,
           Theme = &amp;quot;CleanBlog&amp;quot;,
           UpdatePackages = true,
           Preview = true,
           Watch = true
       });        
   });

Task(&amp;quot;Default&amp;quot;)
   .IsDependentOn(&amp;quot;Build&amp;quot;);    
   
RunTarget(target);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add a file called &lt;code&gt;config.wyam&lt;/code&gt; like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;#recipe Blog
#theme CleanBlog

Settings[Keys.Host] = &amp;quot;yourname.github.io&amp;quot;;
Settings[BlogKeys.Title] = &amp;quot;MegaBlog&amp;quot;;
Settings[BlogKeys.Description] = &amp;quot;Blog of the Gods&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a folder called &lt;code&gt;input&lt;/code&gt; and add a folder called &lt;code&gt;posts&lt;/code&gt; inside that.
Now create &lt;code&gt;input/posts/fist-post.md&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Title: Fist Post! A song of fice and ire
Published: 10/30/2017
Tags: ['Fists']
---

This post is about fists and how clumpy they always are.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! Try running it using Cake. Because Wyam targets an older version of Cake at the time of writing, I'm adding the &lt;code&gt;--settings_skipverification=true&lt;/code&gt; option so that Cake doesn't complain.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cake --settings_skipverification=true -target=Preview
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Open a browser to http://localhost:5080 and see the results. The &lt;code&gt;Preview&lt;/code&gt; target watches for file changes so it can automatically recompile &amp;amp; refresh your browser whenever you save changes.&lt;/p&gt;
&lt;h1 id="automating-deployment"&gt;Automating Deployment&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Install the &lt;a href="https://marketplace.visualstudio.com/items?itemName=cake-build.cake"&gt;Cake build task from the Visual Studio Marketplace&lt;/a&gt; into VSO.&lt;/li&gt;
&lt;li&gt;In Visual Studio Online, create a new, empty build for your repo, selecting an appropriate build agent.&lt;/li&gt;
&lt;li&gt;Add the Cake Build task.&lt;/li&gt;
&lt;li&gt;Select the &lt;code&gt;build.cake&lt;/code&gt; file from the root of your repo as the &lt;em&gt;Cake Script&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Set the &lt;em&gt;Target&lt;/em&gt; to &lt;code&gt;Default&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Optionally add the &lt;code&gt;--settings_skipverification=true&lt;/code&gt; option to &lt;em&gt;Cake Arguments&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Add a new &lt;em&gt;PowerShell Script&lt;/em&gt; build task, set &lt;em&gt;Type&lt;/em&gt; to &lt;code&gt;Inline Script&lt;/code&gt; and add these contents:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;param (
  [string]$Token,
  [string]$UserName,
  [string]$Repository
)

$localFolder = &amp;quot;gh-pages&amp;quot;
$repo = &amp;quot;https://$($UserName):$($Token)&amp;#64;github.com/$($Repository).git&amp;quot;
git clone $repo --branch=master $localFolder

Copy-Item &amp;quot;output\*&amp;quot; $localFolder -recurse

Set-Location $localFolder
git add *
git commit -m &amp;quot;Update.&amp;quot;
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="8"&gt;
&lt;li&gt;Create a new GitHub Personal Access token from GitHub's Developer Settings page, or by &lt;a href="https://github.com/settings/tokens/new"&gt;clicking here&lt;/a&gt;. I added all of the &lt;code&gt;repo&lt;/code&gt; permissions to the token.&lt;/li&gt;
&lt;li&gt;In VSO, add arguments for the script, replacing &lt;code&gt;TOKEN&lt;/code&gt; with your token and replacing the other values as appropriate:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;-Token TOKEN -UserName &amp;quot;ReubenBond&amp;quot; -Repository &amp;quot;ReubenBond/reubenbond.github.io&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="10"&gt;
&lt;li&gt;Up on the &lt;em&gt;Triggers&lt;/em&gt; pane, enable Continuous Integration.&lt;/li&gt;
&lt;li&gt;Click &lt;em&gt;Save &amp;amp; queue&lt;/em&gt;, then cross your fingers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hopefully that's it and you can now add new blog posts to the &lt;code&gt;input/posts&lt;/code&gt; directory.&lt;/p&gt;
</content:encoded>
		</item>
	</channel>
</rss>