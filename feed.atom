<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<link rel="self" href="http://reubenbond.github.io/" />
	<id>http://reubenbond.github.io/</id>
	<title>reublog</title>
	<rights>2018</rights>
	<updated>2018-03-18T22:11:48Z</updated>
	<logo>http://reubenbond.github.io/images/header.jpg</logo>
	<subtitle>reublog</subtitle>
	<entry>
		<link href="http://reubenbond.github.io/posts/codegen-2-il-boogaloo" />
		<link rel="enclosure" type="image" href="http://reubenbond.github.io/images/codegen-2-banner.png" />
		<id>http://reubenbond.github.io/posts/codegen-2-il-boogaloo</id>
		<title>.NET IL Generation - Writing DeepCopy</title>
		<updated>2017-11-04T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;em&gt;This is the second part in a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id="il-generation"&gt;IL Generation&lt;/h3&gt;
&lt;p&gt;&lt;a href="/posts/codegen-1"&gt;Last time&lt;/a&gt;, we skimmed over some methods to generate code on .NET and one of them was emitting IL. IL generation lets us circumvent the rules C# and other languages put in place to protect us from our own stupidity. Without those rules, we can implement all kinds of fancy foot guns. Rules like “don't access private members of foreign types” and “don't modify &lt;code&gt;readonly&lt;/code&gt; fields”. That last one is interesting: C#'s &lt;code&gt;readonly&lt;/code&gt; translates into &lt;code&gt;initonly&lt;/code&gt; on the IL/metadata level so theoretically we shouldn't be able to modify those fields even using IL. As a matter of fact we can, but it comes at a cost: &lt;strong&gt;our IL will no longer be verifiable&lt;/strong&gt;. That means that certain tools will bark at you if you try to write IL code which commits this sin, tools such as &lt;a href="https://docs.microsoft.com/en-us/dotnet/framework/tools/peverify-exe-peverify-tool"&gt;PEVerify&lt;/a&gt; and &lt;a href="https://github.com/dotnet/corert/tree/master/src/ILVerify"&gt;ILVerify&lt;/a&gt;. Verifiable code also has ramifications for &lt;a href="https://docs.microsoft.com/en-us/dotnet/framework/misc/security-transparent-code"&gt;Security-Transparent Code&lt;/a&gt;. Thankfully for us, Code Access Security and Security Transparent Code &lt;a href="https://github.com/dotnet/corefx/blob/master/Documentation/project-docs/porting.md#code-access-security-cas"&gt;don't exist in .NET Core&lt;/a&gt; and they usually don't cause issue for .NET Framework.&lt;/p&gt;
&lt;p&gt;Enough stalling, onto our mission briefing.&lt;/p&gt;
&lt;h3 id="deepcopy"&gt;DeepCopy&lt;/h3&gt;
&lt;p&gt;Today we're going to implement the guts of a library for creating deep copies of objects. Essentially it provides one method:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public static T Copy&amp;lt;T&amp;gt;(T original);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Our library will be called &lt;em&gt;DeepCopy&lt;/em&gt; and the source is up on GitHub at &lt;a href="https://github.com/ReubenBond/DeepCopy"&gt;ReubenBond/DeepCopy&lt;/a&gt; feel free to mess about with it. The majority of the code was adapted from the &lt;a href="https://github.com/dotnet/orleans"&gt;Orleans&lt;/a&gt; codebase.&lt;/p&gt;
&lt;p&gt;Deep copying is important for frameworks such as &lt;a href="https://github.com/dotnet/orleans"&gt;Orleans&lt;/a&gt;, since it allows us to safely send mutable objects between grains on the same node without having to first serialize &amp;amp; then deserialze them, among other things. Of course, immutable objects (such as strings) are shared without copying. Oddly enough, serializing then deserializing an object is the &lt;a href="https://stackoverflow.com/a/78612/635314"&gt;accepted Stack Overflow answer&lt;/a&gt; to the question of “how can I deep copy an object?”.&lt;/p&gt;
&lt;p&gt;Let's see if we can fix that.&lt;/p&gt;
&lt;h3 id="battle-plan"&gt;Battle Plan&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;Copy&lt;/code&gt; method will recursively copy every field in the input object into a new instance of the same type. It must be able to deal with multiple references to the same object, so that if the user provides an object which contains a reference to itself then the result will also contain a reference to itself. That means we'll need to perform reference tracking. That's easy to do: we maintain a &lt;code&gt;Dictionary&amp;lt;object, object&amp;gt;&lt;/code&gt; which maps from original object to copy object. Our main &lt;code&gt;Copy&amp;lt;T&amp;gt;(T orig)&lt;/code&gt; method will call into a helper method with that dictionary as a parameter:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;public static T Copy&amp;lt;T&amp;gt;(T original, CopyContext context)
{
  /* TODO: implementation */
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The copy routine is roughly as follows:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If the input is &lt;code&gt;null&lt;/code&gt;, return &lt;code&gt;null&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If the input has already been copied (or is currently being copied), return its copy.&lt;/li&gt;
&lt;li&gt;If the input is 'immutable', return the input.&lt;/li&gt;
&lt;li&gt;If the input is an array, copy each element into a new array and return it.&lt;/li&gt;
&lt;li&gt;Create a new instance of the input type and recursively copy each field from the input to the output and return it.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Our definition of immutable is simple: the type is either a primitive or it's marked using a special &lt;code&gt;[Immutable]&lt;/code&gt; attribute. More elaborate immutability could be probably be soundly implemented, so &lt;a href="https://github.com/ReubenBond/DeepCopy/pull/new/master"&gt;submit a PR&lt;/a&gt; if you've improved upon it.&lt;/p&gt;
&lt;p&gt;Everything but the last step in our routine is simple enough to do without generating code. The last step, recursively copying each field, can be performed using reflection to get and set field values. Reflection is a real performance killer on the hot path, though, and so we're going to go our own route using IL.&lt;/p&gt;
&lt;h3 id="diving-into-the-code"&gt;Diving Into The Code&lt;/h3&gt;
&lt;p&gt;The main IL generation in &lt;em&gt;DeepCopy&lt;/em&gt; occurs inside &lt;a href="https://github.com/ReubenBond/DeepCopy/blob/1b00515b6b6aece93b4bea61bf40780265c2e349/src/DeepCopy/CopierGenerator.cs#L52"&gt;&lt;code&gt;CopierGenerator.cs&lt;/code&gt;&lt;/a&gt; in the &lt;code&gt;CreateCopier&amp;lt;T&amp;gt;(Type type)&lt;/code&gt; method. Let's walk through it:&lt;/p&gt;
&lt;p&gt;First we create a new &lt;code&gt;DynamicMethod&lt;/code&gt; which will hold the IL code we emit. We have to tell &lt;code&gt;DynamicMethod&lt;/code&gt; what the signature of the type we're creating is. In our case, it's a generic delegate type, &lt;code&gt;delegate T DeepCopyDelegate&amp;lt;T&amp;gt;(T original, CopyContext context)&lt;/code&gt;. Then we get the &lt;code&gt;ILGenerator&lt;/code&gt; for the method so that we can begin emitting IL code to it.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;var dynamicMethod = new DynamicMethod(
    type.Name + &amp;quot;DeepCopier&amp;quot;,
    typeof(T), // The return type of the delegate
    new[] {typeof(T), typeof(CopyContext)}, // The parameter types of the delegate.
    typeof(CopierGenerator).Module,
    true);

var il = dynamicMethod.GetILGenerator(); 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The IL is going to be rather complicated because it needs to deal with immutable types and value types, but let's walk through it bit-by-bit.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// Declare a variable to store the result.
il.DeclareLocal(type);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we need to initialize our new local variable to a new instance of the input type. There are 3 cases to consider, each corresponding to a block in the following code:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The type is a value type (struct). Initialize it by essentially using a &lt;code&gt;default(T)&lt;/code&gt; expression.&lt;/li&gt;
&lt;li&gt;The type has a parameterless constructor. Initialize it by calling &lt;code&gt;new T()&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The type does not have a parameterless constructor. In this case we ask the framework for help and we call &lt;code&gt;FormatterServices.GetUninitializedObject(type)&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// Construct the result.
var constructorInfo = type.GetConstructor(Type.EmptyTypes);
if (type.IsValueType)
{
    // Value types can be initialized directly.
    // C#: result = default(T);
    il.Emit(OpCodes.Ldloca_S, (byte)0);
    il.Emit(OpCodes.Initobj, type);
}
else if (constructorInfo != null)
{
    // If a default constructor exists, use that.
    // C#: result = new T();
    il.Emit(OpCodes.Newobj, constructorInfo);
    il.Emit(OpCodes.Stloc_0);
}
else
{
    // If no default constructor exists, create an instance using GetUninitializedObject
    // C#: result = (T)FormatterServices.GetUninitializedObject(type);
    var field = this.fieldBuilder.GetOrCreateStaticField(type);
    il.Emit(OpCodes.Ldsfld, field);
    il.Emit(OpCodes.Call, this.methodInfos.GetUninitializedObject);
    il.Emit(OpCodes.Castclass, type);
    il.Emit(OpCodes.Stloc_0);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="interlude-what-il-should-we-emit"&gt;Interlude - What IL Should We Emit?&lt;/h3&gt;
&lt;p&gt;Even if you're not a first-timer with IL, it's not always easy to work out what IL you need to emit to achieve the desired result. This is where tools come in to help you. Personally I typically write my code in C# first, slap it into &lt;a href="https://www.linqpad.net/"&gt;LINQPad&lt;/a&gt;, hit run and open the IL tab in the output. It's great for experimenting.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/linqpad-il.png" class="img-fluid" alt="LINQPad is seriously handy!" /&gt;&lt;/p&gt;
&lt;p&gt;Another option is to use a decompiler/disassembler like &lt;a href="https://www.jetbrains.com/decompiler/"&gt;JetBrains' dotPeek&lt;/a&gt;. You would compile your assembly and open it in dotPeek to reveal the IL.&lt;/p&gt;
&lt;p&gt;Finally, if you're like me, then &lt;a href="https://www.jetbrains.com/resharper/"&gt;ReSharper&lt;/a&gt; is indispensible. It's like coding on rails (train tracks, not Ruby). ReSharper comes with a convenient &lt;a href="https://www.jetbrains.com/help/resharper/Viewing_Intermediate_Language.html"&gt;IL Viewer&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="/images/resharper-il.png" class="img-fluid" alt="ReSharper IL Viewer" /&gt;&lt;/p&gt;
&lt;p&gt;Alright, so that's how you work out what IL to generate. You'll occasionally want to &lt;a href="https://msdn.microsoft.com/en-us/library/system.reflection.emit.opcodes(v=vs.110).aspx"&gt;visit the docs&lt;/a&gt;, too.&lt;/p&gt;
&lt;h3 id="back-to-emit"&gt;Back To Emit&lt;/h3&gt;
&lt;p&gt;Now we have a new instance of the input type stored in our local result variable. Before we do anything else, we must record the newly created reference. We push each argument onto the stack in order and use the non-virtual &lt;code&gt;Call&lt;/code&gt; op-code to invoke &lt;code&gt;context.RecordObject(original, result)&lt;/code&gt;. We can use the non-virtual &lt;code&gt;Call&lt;/code&gt; op-code to call &lt;code&gt;CopyContext.RecordObject&lt;/code&gt; because &lt;code&gt;CopyContext&lt;/code&gt; is a &lt;code&gt;sealed&lt;/code&gt; class. If it wasn't, we would use &lt;code&gt;Callvirt&lt;/code&gt; instead.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// An instance of a value types can never appear multiple times in an object graph,
// so only record reference types in the context.
if (!type.IsValueType)
{
    // Record the object.
    // C#: context.RecordObject(original, result);
    il.Emit(OpCodes.Ldarg_1); // context
    il.Emit(OpCodes.Ldarg_0); // original
    il.Emit(OpCodes.Ldloc_0); // result, i.e, the copy of original
    il.Emit(OpCodes.Call, this.methodInfos.RecordObject);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On to the meat of our generator! With the accounting out of the way, we can enumerate over each field and generate code to copy each one into our &lt;code&gt;result&lt;/code&gt; variable. The comments narrate the process:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// Copy each field.
foreach (var field in this.copyPolicy.GetCopyableFields(type))
{
    // Load a reference to the result.
    if (type.IsValueType)
    {
        // Value types need to be loaded by address rather than copied onto the stack.
        il.Emit(OpCodes.Ldloca_S, (byte)0);
    }
    else
    {
        il.Emit(OpCodes.Ldloc_0);
    }

    // Load the field from the result.
    il.Emit(OpCodes.Ldarg_0);
    il.Emit(OpCodes.Ldfld, field);

    // Deep-copy the field if needed, otherwise just leave it as-is.
    if (!this.copyPolicy.IsShallowCopyable(field.FieldType))
    {
        // Copy the field using the generic Copy&amp;lt;T&amp;gt; method.
        // C#: Copy&amp;lt;T&amp;gt;(field)
        il.Emit(OpCodes.Ldarg_1);
        il.Emit(OpCodes.Call, this.methodInfos.CopyInner.MakeGenericMethod(field.FieldType));
    }

    // Store the copy of the field on the result.
    il.Emit(OpCodes.Stfld, field);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Return the result and build our delegate using &lt;code&gt;CreateDelegate&lt;/code&gt; so that we can start using it immediately.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;// C#: return result;
il.Emit(OpCodes.Ldloc_0);
il.Emit(OpCodes.Ret);
return dynamicMethod.CreateDelegate(typeof(DeepCopyDelegate&amp;lt;T&amp;gt;)) as DeepCopyDelegate&amp;lt;T&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That's the guts of the library. Of course many details were left out, such as:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Caching &lt;code&gt;Type&lt;/code&gt; values in static fields so that we can reference them from our generated code. See &lt;a href="https://github.com/ReubenBond/DeepCopy/blob/1b00515b6b6aece93b4bea61bf40780265c2e349/src/DeepCopy/StaticFieldBuilder.cs#L64"&gt;&lt;code&gt;StaticFieldBuilder.cs&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The special handling of arrays in &lt;a href="https://github.com/ReubenBond/DeepCopy/blob/1b00515b6b6aece93b4bea61bf40780265c2e349/src/DeepCopy/DeepCopier.cs#L69"&gt;&lt;code&gt;DeepCopier.cs&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Optimizations such as using &lt;a href="https://github.com/ReubenBond/DeepCopy/blob/master/src/DeepCopy/CachedReadConcurrentDictionary.cs"&gt;&lt;code&gt;CachedReadConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt;&lt;/a&gt; for a slight improvement over &lt;code&gt;ConcurrentDictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; for workloads with a diminishing write volume.&lt;/li&gt;
&lt;/ul&gt;
</content>
		<summary>&lt;p&gt;&lt;em&gt;This is the second part in a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<link href="http://reubenbond.github.io/posts/codegen-1" />
		<link rel="enclosure" type="image" href="http://reubenbond.github.io/images/codegen-1-banner.png" />
		<id>http://reubenbond.github.io/posts/codegen-1</id>
		<title>Code Generation on .NET</title>
		<updated>2017-11-01T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;em&gt;This is the first part in what's hopefully a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Almost every .NET application relies on code generation in some form, usually because they rely on a library which generates code as a part of how it functions. Eg, Json.NET &lt;a href="https://github.com/JamesNK/Newtonsoft.Json/blob/473a7721bd67cca8fef1ecc37da1951a1c180022/Src/Newtonsoft.Json/Utilities/DynamicReflectionDelegateFactory.cs"&gt;leverages code generation&lt;/a&gt; and so does &lt;a href="https://github.com/aspnet/MvcPrecompilation"&gt;ASP.NET&lt;/a&gt;, Entity Framework, &lt;a href="https://github.com/dotnet/orleans"&gt;Orleans&lt;/a&gt;, most serialization libraries, many dependency injection libraries, and probably every test mocking library.&lt;/p&gt;
&lt;p&gt;Let's skip past &lt;em&gt;why&lt;/em&gt; code generation is useful and jump straight into a high level overview of code generation technologies for .NET.&lt;/p&gt;
&lt;h2 id="kinds-of-code-generation"&gt;Kinds of Code Generation&lt;/h2&gt;
&lt;p&gt;The 3 code gen methods for .NET which we'll discuss are: &lt;strong&gt;Expression Trees&lt;/strong&gt;, &lt;strong&gt;IL Generation&lt;/strong&gt;, and &lt;strong&gt;Syntax Generation&lt;/strong&gt;. There are other methods, such as text templating (eg using T4). Here are the pros and cons of each as I see them.&lt;/p&gt;
&lt;h3 id="expression-trees"&gt;Expression Trees&lt;/h3&gt;
&lt;p&gt;Using &lt;strong&gt;LINQ Expression Trees&lt;/strong&gt; to compile expressions at runtime.&lt;/p&gt;
&lt;p&gt;&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Easy to use, expressive API.&lt;br/&gt;
&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Allows level of access to private members.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Not fully supported on AOT-only platforms like iOS. Expression Trees will be interpreted instead of compiled.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Not all language constructs are supported.&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="il-generation"&gt;IL Generation&lt;/h3&gt;
&lt;p&gt;Using &lt;strong&gt;Reflection.Emit&lt;/strong&gt; to dynamically create types and methods using Common Intermediate Langage (known as CIL or just IL), which is the assembly language of the CLR.&lt;/p&gt;
&lt;p&gt;&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Can produce code which cannot be expressed in C#, eg access private members of some type.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Very verbose.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Very difficult to debug: Visual Studio will not show you IL for dynamic methods, they are represented as an opaque &lt;em&gt;Lightweight Function&lt;/em&gt; entry in the stack trace view.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Difficult to implement higher level features like C#'s &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Not supported on AOT-only platforms like iOS.&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="syntax-generation"&gt;Syntax Generation&lt;/h3&gt;
&lt;p&gt;Using &lt;strong&gt;Roslyn&lt;/strong&gt; or some other API to generate C# syntax trees or source code and compile it either at runtime or when the target project is built.&lt;/p&gt;
&lt;p&gt;&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Easy access to all C# language features.&lt;br/&gt;
&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Supported on AOT-only platforms, since output is C# code which can be compiled.&lt;br/&gt;
&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Well supported: it's the C# compiler, it's not going away or being deprecated any time soon.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; API isn't always obvious since the primary purpose of the API is parsing/compiling code rather than generating it.&lt;br/&gt;
&lt;em&gt;Note:&lt;/em&gt; to support runtime code generationn you need to include Roslyn with your app, which can add around 6MB to your distribution.&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="orleans"&gt;Orleans&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/orleans"&gt;Microsoft Orleans&lt;/a&gt; uses the latter two approaches: IL and Roslyn. It uses Roslyn wherever possible, since it allows for easy access to C# language features like &lt;code&gt;async&lt;/code&gt; and since it's easy to comprehend both the code generator and the generated code. Otherwise, IL generation is used for two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Generating code at runtime. For example &lt;a href="https://github.com/dotnet/orleans/blob/375a98191ca40c27ca8ed61199a6a77a7995e75e/src/Orleans.Core/Serialization/ILSerializerGenerator.cs"&gt;&lt;code&gt;ILSerializerGenerator&lt;/code&gt;&lt;/a&gt; generates serializers as a last resort for types which C# serializers couldn't be generated for (for example, private inner classes). It's a faster and less restricted alternative to .NET's &lt;a href="https://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v=vs.110).aspx"&gt;&lt;code&gt;BinaryFormatter&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Producing code which cannot be expressed in C#. For example, &lt;a href="https://github.com/dotnet/orleans/blob/375a98191ca40c27ca8ed61199a6a77a7995e75e/src/Orleans.Core.Abstractions/Serialization/FieldUtils.cs#"&gt;&lt;code&gt;FieldUtils&lt;/code&gt;&lt;/a&gt; provides access to private fields and methods for serialization.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="general-strategy"&gt;General Strategy&lt;/h2&gt;
&lt;p&gt;Regardless of which technology a library makes use of, code generation typically involves two phases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Metadata Collection
&lt;ul&gt;
&lt;li&gt;The code generator takes some input and creates an abstract representation of it in order to drive the code synthesis process.&lt;/li&gt;
&lt;li&gt;Eg, a library for deeply cloning objects might take a &lt;code&gt;Type&lt;/code&gt; as input and generate an object describing each field in that type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Code Synthesis
&lt;ul&gt;
&lt;li&gt;The code generator uses the metadata model to drive the process of actually generating code (LINQ expressions, IL instructions, syntax tree nodes).&lt;/li&gt;
&lt;li&gt;Eg, our deep cloning library will generate a method which takes an object of the specified type from the metadata model and then recursively copy each of the fields.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The two phases can be merged for simple code generators. Orleans uses two phases. In phase 1, the input assembly is scanned and metadata is collected for types matching various criteria: Grain classes, Grain interfaces, serializable types, and custom serializer registrations. In phase 2, support classes are generated. For example, each grain interface has two classes generated: an RPC proxy and an RPC stub.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;That's enough for now. Maybe next time we'll take a look at writing that hypothetical deep cloning library using IL generation. After that, we can take a look at a serialization library I've been working on which uses Roslyn for both metadata collection and syntax generation. If either of those things are interesting to you, let me know here or on &lt;a href="https://twitter.com/reubenbond"&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;a href="/posts/codegen-2-il-boogaloo"&gt;&lt;strong&gt;Next Post: .NET IL Generation - Writing DeepCopy&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;em&gt;This is the first part in what's hopefully a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<link href="http://reubenbond.github.io/posts/2017-Oct-30-setting-up-wyam" />
		<link rel="enclosure" type="image" href="http://reubenbond.github.io/images/header.jpg" />
		<id>http://reubenbond.github.io/posts/2017-Oct-30-setting-up-wyam</id>
		<title>Deploying Wyam To GitHub Using Visual Studio Online</title>
		<updated>2017-10-30T00:00:00Z</updated>
		<content>&lt;p&gt;Here goes nothing! This blog is built with &lt;a href="https://twitter.com/daveaglick"&gt;Dave Glick's&lt;/a&gt; &lt;a href="https://wyam.io/"&gt;Wyam&lt;/a&gt; static site generator and deployed from a git repo in Visual Studio Online to GitHub Pages. Here's how to set up something similar.&lt;/p&gt;
&lt;h1 id="prerequisites"&gt;Prerequisites&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;A Visual Studio Online repository for your blog source.
&lt;ul&gt;
&lt;li&gt;You could have also VSO pull the source from GitHub or somewhere else instead, but I haven't covered that here.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A GitHub repository which will serve the compiled output via GitHub Pages.
&lt;ul&gt;
&lt;li&gt;I created a repository called &lt;a href="https://github.com/ReubenBond/reubenbond.github.io"&gt;&lt;code&gt;reubenbond.github.io&lt;/code&gt;&lt;/a&gt; under my profile, &lt;a href="https://github.com/ReubenBond/"&gt;&lt;code&gt;ReubenBond&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cake so you can test it out locally. Install it via &lt;a href="https://chocolatey.org/"&gt;Chocolatey&lt;/a&gt;: &lt;code&gt;choco install cake.portable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="kick-starting-wyam-with-cake"&gt;Kick-starting Wyam with Cake&lt;/h1&gt;
&lt;p&gt;Create a file called &lt;code&gt;build.cake&lt;/code&gt; in the root of your repo with these contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;#tool nuget:?package=Wyam
#addin nuget:?package=Cake.Wyam

var target = Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;);

Task(&amp;quot;Build&amp;quot;)
   .Does(() =&amp;gt;
   {
       Wyam(new WyamSettings
       {
           Recipe = &amp;quot;Blog&amp;quot;,
           Theme = &amp;quot;CleanBlog&amp;quot;,
           UpdatePackages = true
       });
   });
   
Task(&amp;quot;Preview&amp;quot;)
   .Does(() =&amp;gt;
   {
       Wyam(new WyamSettings
       {
           Recipe = &amp;quot;Blog&amp;quot;,
           Theme = &amp;quot;CleanBlog&amp;quot;,
           UpdatePackages = true,
           Preview = true,
           Watch = true
       });        
   });

Task(&amp;quot;Default&amp;quot;)
   .IsDependentOn(&amp;quot;Build&amp;quot;);    
   
RunTarget(target);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add a file called &lt;code&gt;config.wyam&lt;/code&gt; like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;#recipe Blog
#theme CleanBlog

Settings[Keys.Host] = &amp;quot;yourname.github.io&amp;quot;;
Settings[BlogKeys.Title] = &amp;quot;MegaBlog&amp;quot;;
Settings[BlogKeys.Description] = &amp;quot;Blog of the Gods&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a folder called &lt;code&gt;input&lt;/code&gt; and add a folder called &lt;code&gt;posts&lt;/code&gt; inside that.
Now create &lt;code&gt;input/posts/fist-post.md&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Title: Fist Post! A song of fice and ire
Published: 10/30/2017
Tags: ['Fists']
---

This post is about fists and how clumpy they always are.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! Try running it using Cake. Because Wyam targets an older version of Cake at the time of writing, I'm adding the &lt;code&gt;--settings_skipverification=true&lt;/code&gt; option so that Cake doesn't complain.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cake --settings_skipverification=true -target=Preview
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Open a browser to &lt;a href="http://localhost:5080"&gt;http://localhost:5080&lt;/a&gt; and see the results. The &lt;code&gt;Preview&lt;/code&gt; target watches for file changes so it can automatically recompile &amp;amp; refresh your browser whenever you save changes.&lt;/p&gt;
&lt;h1 id="automating-deployment"&gt;Automating Deployment&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Install the &lt;a href="https://marketplace.visualstudio.com/items?itemName=cake-build.cake"&gt;Cake build task from the Visual Studio Marketplace&lt;/a&gt; into VSO.&lt;/li&gt;
&lt;li&gt;In Visual Studio Online, create a new, empty build for your repo, selecting an appropriate build agent.&lt;/li&gt;
&lt;li&gt;Add the Cake Build task.&lt;/li&gt;
&lt;li&gt;Select the &lt;code&gt;build.cake&lt;/code&gt; file from the root of your repo as the &lt;em&gt;Cake Script&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Set the &lt;em&gt;Target&lt;/em&gt; to &lt;code&gt;Default&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Optionally add the &lt;code&gt;--settings_skipverification=true&lt;/code&gt; option to &lt;em&gt;Cake Arguments&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Add a new &lt;em&gt;PowerShell Script&lt;/em&gt; build task, set &lt;em&gt;Type&lt;/em&gt; to &lt;code&gt;Inline Script&lt;/code&gt; and add these contents:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;param (
  [string]$Token,
  [string]$UserName,
  [string]$Repository
)

$localFolder = &amp;quot;gh-pages&amp;quot;
$repo = &amp;quot;https://$($UserName):$($Token)&amp;#64;github.com/$($Repository).git&amp;quot;
git clone $repo --branch=master $localFolder

Copy-Item &amp;quot;output\*&amp;quot; $localFolder -recurse

Set-Location $localFolder
git add *
git commit -m &amp;quot;Update.&amp;quot;
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="8"&gt;
&lt;li&gt;Create a new GitHub Personal Access token from GitHub's Developer Settings page, or by &lt;a href="https://github.com/settings/tokens/new"&gt;clicking here&lt;/a&gt;. I added all of the &lt;code&gt;repo&lt;/code&gt; permissions to the token.&lt;/li&gt;
&lt;li&gt;In VSO, add arguments for the script, replacing &lt;code&gt;TOKEN&lt;/code&gt; with your token and replacing the other values as appropriate:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;-Token TOKEN -UserName &amp;quot;ReubenBond&amp;quot; -Repository &amp;quot;ReubenBond/reubenbond.github.io&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="10"&gt;
&lt;li&gt;Up on the &lt;em&gt;Triggers&lt;/em&gt; pane, enable Continuous Integration.&lt;/li&gt;
&lt;li&gt;Click &lt;em&gt;Save &amp;amp; queue&lt;/em&gt;, then cross your fingers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hopefully that's it and you can now add new blog posts to the &lt;code&gt;input/posts&lt;/code&gt; directory.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;Here goes nothing! This blog is built with &lt;a href="https://twitter.com/daveaglick"&gt;Dave Glick's&lt;/a&gt; &lt;a href="https://wyam.io/"&gt;Wyam&lt;/a&gt; static site generator and deployed from a git repo in Visual Studio Online to GitHub Pages. Here's how to set up something similar.&lt;/p&gt;</summary>
	</entry>
</feed>