<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<link rel="self" href="http://reubenbond.github.io/" />
	<id>http://reubenbond.github.io/</id>
	<title>reublog</title>
	<rights>2017</rights>
	<updated>2017-11-02T01:49:12Z</updated>
	<logo>http://reubenbond.github.io/images/header.jpg</logo>
	<subtitle>reublog</subtitle>
	<entry>
		<link href="http://reubenbond.github.io/posts/codegen-1" />
		<link rel="enclosure" type="image" href="http://reubenbond.github.io/images/codegen-1-banner.png" />
		<id>http://reubenbond.github.io/posts/codegen-1</id>
		<title>Code Generation on .NET</title>
		<updated>2017-11-01T00:00:00Z</updated>
		<content>&lt;p&gt;&lt;em&gt;This is the first part in what's hopefully a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Almost every .NET application relies on code generation in some form, usually because they rely on a library which generates code as a part of how it functions. Eg, Json.NET &lt;a href="https://github.com/JamesNK/Newtonsoft.Json/blob/473a7721bd67cca8fef1ecc37da1951a1c180022/Src/Newtonsoft.Json/Utilities/DynamicReflectionDelegateFactory.cs"&gt;leverages code generation&lt;/a&gt; and so does &lt;a href="https://github.com/aspnet/MvcPrecompilation"&gt;ASP.NET&lt;/a&gt;, Entity Framework, &lt;a href="https://github.com/dotnet/orleans"&gt;Orleans&lt;/a&gt;, most serialization libraries, many dependency injection libraries, and probably every test mocking library.&lt;/p&gt;
&lt;p&gt;Let's skip past &lt;em&gt;why&lt;/em&gt; code generation is useful and jump straight into a high level overview of code generation technologies for .NET.&lt;/p&gt;
&lt;h2 id="kinds-of-code-generation"&gt;Kinds of Code Generation&lt;/h2&gt;
&lt;p&gt;The 3 code gen methods for .NET which we'll discuss are: &lt;strong&gt;Expression Trees&lt;/strong&gt;, &lt;strong&gt;IL Generation&lt;/strong&gt;, and &lt;strong&gt;Syntax Generation&lt;/strong&gt;. There are other methods, such as text templating (eg using T4). Here are the pros and cons of each as I see them.&lt;/p&gt;
&lt;h3 id="expression-trees"&gt;Expression Trees&lt;/h3&gt;
&lt;p&gt;Using &lt;strong&gt;LINQ Expression Trees&lt;/strong&gt; to compile expressions at runtime.&lt;/p&gt;
&lt;p&gt;&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Easy to use, expressive API.&lt;br/&gt;
&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Allows level of access to private members.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Not fully supported on AOT-only platforms like iOS. Expression Trees will be interpreted instead of compiled.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Not all language constructs are supported.&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="il-generation"&gt;IL Generation&lt;/h3&gt;
&lt;p&gt;Using &lt;strong&gt;Reflection.Emit&lt;/strong&gt; to dynamically create types and methods using Common Intermediate Langage (known as CIL or just IL), which is the assembly language of the CLR.&lt;/p&gt;
&lt;p&gt;&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Can produce code which cannot be expressed in C#, eg access private members of some type.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Very verbose.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Very difficult to debug: Visual Studio will not show you IL for dynamic methods, they are represented as an opaque &lt;em&gt;Lightweight Function&lt;/em&gt; entry in the stack trace view.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Difficult to implement higher level features like C#'s &lt;code&gt;async&lt;/code&gt;/&lt;code&gt;await&lt;/code&gt;.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Not supported on AOT-only platforms like iOS.&lt;br/&gt;&lt;/p&gt;
&lt;h3 id="syntax-generation"&gt;Syntax Generation&lt;/h3&gt;
&lt;p&gt;Using &lt;strong&gt;Roslyn&lt;/strong&gt; or some other API to generate C# syntax trees or source code and compile it either at runtime or when the target project is built.&lt;/p&gt;
&lt;p&gt;&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Easy access to all C# language features.&lt;br/&gt;
&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Supported on AOT-only platforms, since output is C# code which can be compiled.&lt;br/&gt;
&lt;i class="fa fa-check text-success fa-fw" aria-hidden="true"&gt;&lt;/i&gt; Well supported: it's the C# compiler, it's not going away or being deprecated any time soon.&lt;br/&gt;
&lt;i class="fa fa-times text-danger fa-fw" aria-hidden="true"&gt;&lt;/i&gt; API isn't always obvious since the primary purpose of the API is parsing/compiling code rather than generating it.&lt;br/&gt;
&lt;em&gt;Note:&lt;/em&gt; to support runtime code generationn you need to include Roslyn with your app, which can add around 6MB to your distribution.&lt;br/&gt;&lt;/p&gt;
&lt;h2 id="orleans"&gt;Orleans&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/orleans"&gt;Microsoft Orleans&lt;/a&gt; uses the latter two approaches: IL and Roslyn. It uses Rosyn wherever possible, since it allows for easy access to C# language features like &lt;code&gt;async&lt;/code&gt; and since it's easy to comprehend both the code generator and the generated code. Otherwise, IL generation is used for two things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Generating code at runtime. For example &lt;a href="https://github.com/dotnet/orleans/blob/375a98191ca40c27ca8ed61199a6a77a7995e75e/src/Orleans.Core/Serialization/ILSerializerGenerator.cs"&gt;&lt;code&gt;ILSerializerGenerator&lt;/code&gt;&lt;/a&gt; generates serializers as a last resort for types which C# serializers couldn't be generated for (for example, private inner classes). It's a faster and less restricted alternative to .NET's &lt;a href="https://msdn.microsoft.com/en-us/library/system.runtime.serialization.formatters.binary.binaryformatter(v=vs.110).aspx"&gt;&lt;code&gt;BinaryFormatter&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Producing code which cannot be expressed in C#. For example, &lt;a href="https://github.com/dotnet/orleans/blob/375a98191ca40c27ca8ed61199a6a77a7995e75e/src/Orleans.Core.Abstractions/Serialization/FieldUtils.cs#"&gt;&lt;code&gt;FieldUtils&lt;/code&gt;&lt;/a&gt; provides access to private fields and methods for serialization.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="general-strategy"&gt;General Strategy&lt;/h2&gt;
&lt;p&gt;Regardless of which technology a library makes use of, code generation typically involves two phases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Metadata Collection
&lt;ul&gt;
&lt;li&gt;The code generator takes some input and creates an abstract representation of it in order to drive the code synthesis process.&lt;/li&gt;
&lt;li&gt;Eg, a library for deeply cloning objects might take a &lt;code&gt;Type&lt;/code&gt; as input and generate an object describing each field in that type.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Code Synthesis
&lt;ul&gt;
&lt;li&gt;The code generator uses the metadata model to drive the process of actually generating code (LINQ expressions, IL instructions, syntax tree nodes).&lt;/li&gt;
&lt;li&gt;Eg, our deep cloning library will generate a method which takes an object of the specified type from the metadata model and then recursively copy each of the fields.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The two phases can be merged for simple code generators. Orleans uses two phases. In phase 1, the input assembly is scanned and metadata is collected for types matching various criteria: Grain classes, Grain interfaces, serializable types, and custom serializer registrations. In phase 2, support classes are generated. For example, each grain interface has two classes generated: an RPC proxy and an RPC stub.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;That's enough for now. Maybe next time we'll take a look at writing that hypothetical deep cloning library using IL generation. After that, we can take a look at a serialization library I've been working on which uses Roslyn for both metadata collection and syntax generation. If either of those things are interesting to you, let me know here or on &lt;a href="https://twitter.com/reubenbond"&gt;Twitter&lt;/a&gt;.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;&lt;em&gt;This is the first part in what's hopefully a series of short posts covering code generation on the .NET platform.&lt;/em&gt;&lt;/p&gt;</summary>
	</entry>
	<entry>
		<link href="http://reubenbond.github.io/posts/2017-Oct-30-setting-up-wyam" />
		<link rel="enclosure" type="image" href="http://reubenbond.github.io/images/header.jpg" />
		<id>http://reubenbond.github.io/posts/2017-Oct-30-setting-up-wyam</id>
		<title>Deploying Wyam To GitHub Using Visual Studio Online</title>
		<updated>2017-10-30T00:00:00Z</updated>
		<content>&lt;p&gt;Here goes nothing! This blog is built with &lt;a href="https://twitter.com/daveaglick"&gt;Dave Glick's&lt;/a&gt; &lt;a href="https://wyam.io/"&gt;Wyam&lt;/a&gt; static site generator and deployed from a git repo in Visual Studio Online to GitHub Pages. Here's how to set up something similar.&lt;/p&gt;
&lt;h1 id="prerequisites"&gt;Prerequisites&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;A Visual Studio Online repository for your blog source.
&lt;ul&gt;
&lt;li&gt;You could have also VSO pull the source from GitHub or somewhere else instead, but I haven't covered that here.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;A GitHub repository which will serve the compiled output via GitHub Pages.
&lt;ul&gt;
&lt;li&gt;I created a repository called &lt;a href="https://github.com/ReubenBond/reubenbond.github.io"&gt;&lt;code&gt;reubenbond.github.io&lt;/code&gt;&lt;/a&gt; under my profile, &lt;a href="https://github.com/ReubenBond/"&gt;&lt;code&gt;ReubenBond&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Cake so you can test it out locally. Install it via &lt;a href="https://chocolatey.org/"&gt;Chocolatey&lt;/a&gt;: &lt;code&gt;choco install cake.portable&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="kick-starting-wyam-with-cake"&gt;Kick-starting Wyam with Cake&lt;/h1&gt;
&lt;p&gt;Create a file called &lt;code&gt;build.cake&lt;/code&gt; in the root of your repo with these contents:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;#tool nuget:?package=Wyam
#addin nuget:?package=Cake.Wyam

var target = Argument(&amp;quot;target&amp;quot;, &amp;quot;Default&amp;quot;);

Task(&amp;quot;Build&amp;quot;)
   .Does(() =&amp;gt;
   {
       Wyam(new WyamSettings
       {
           Recipe = &amp;quot;Blog&amp;quot;,
           Theme = &amp;quot;CleanBlog&amp;quot;,
           UpdatePackages = true
       });
   });
   
Task(&amp;quot;Preview&amp;quot;)
   .Does(() =&amp;gt;
   {
       Wyam(new WyamSettings
       {
           Recipe = &amp;quot;Blog&amp;quot;,
           Theme = &amp;quot;CleanBlog&amp;quot;,
           UpdatePackages = true,
           Preview = true,
           Watch = true
       });        
   });

Task(&amp;quot;Default&amp;quot;)
   .IsDependentOn(&amp;quot;Build&amp;quot;);    
   
RunTarget(target);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Add a file called &lt;code&gt;config.wyam&lt;/code&gt; like so:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-C#"&gt;#recipe Blog
#theme CleanBlog

Settings[Keys.Host] = &amp;quot;yourname.github.io&amp;quot;;
Settings[BlogKeys.Title] = &amp;quot;MegaBlog&amp;quot;;
Settings[BlogKeys.Description] = &amp;quot;Blog of the Gods&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Create a folder called &lt;code&gt;input&lt;/code&gt; and add a folder called &lt;code&gt;posts&lt;/code&gt; inside that.
Now create &lt;code&gt;input/posts/fist-post.md&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Title: Fist Post! A song of fice and ire
Published: 10/30/2017
Tags: ['Fists']
---

This post is about fists and how clumpy they always are.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Great! Try running it using Cake. Because Wyam targets an older version of Cake at the time of writing, I'm adding the &lt;code&gt;--settings_skipverification=true&lt;/code&gt; option so that Cake doesn't complain.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cake --settings_skipverification=true -target=Preview
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Open a browser to &lt;a href="http://localhost:5080"&gt;http://localhost:5080&lt;/a&gt; and see the results. The &lt;code&gt;Preview&lt;/code&gt; target watches for file changes so it can automatically recompile &amp;amp; refresh your browser whenever you save changes.&lt;/p&gt;
&lt;h1 id="automating-deployment"&gt;Automating Deployment&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Install the &lt;a href="https://marketplace.visualstudio.com/items?itemName=cake-build.cake"&gt;Cake build task from the Visual Studio Marketplace&lt;/a&gt; into VSO.&lt;/li&gt;
&lt;li&gt;In Visual Studio Online, create a new, empty build for your repo, selecting an appropriate build agent.&lt;/li&gt;
&lt;li&gt;Add the Cake Build task.&lt;/li&gt;
&lt;li&gt;Select the &lt;code&gt;build.cake&lt;/code&gt; file from the root of your repo as the &lt;em&gt;Cake Script&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Set the &lt;em&gt;Target&lt;/em&gt; to &lt;code&gt;Default&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Optionally add the &lt;code&gt;--settings_skipverification=true&lt;/code&gt; option to &lt;em&gt;Cake Arguments&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;Add a new &lt;em&gt;PowerShell Script&lt;/em&gt; build task, set &lt;em&gt;Type&lt;/em&gt; to &lt;code&gt;Inline Script&lt;/code&gt; and add these contents:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code class="language-powershell"&gt;param (
  [string]$Token,
  [string]$UserName,
  [string]$Repository
)

$localFolder = &amp;quot;gh-pages&amp;quot;
$repo = &amp;quot;https://$($UserName):$($Token)&amp;#64;github.com/$($Repository).git&amp;quot;
git clone $repo --branch=master $localFolder

Copy-Item &amp;quot;output\*&amp;quot; $localFolder -recurse

Set-Location $localFolder
git add *
git commit -m &amp;quot;Update.&amp;quot;
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="8"&gt;
&lt;li&gt;Create a new GitHub Personal Access token from GitHub's Developer Settings page, or by &lt;a href="https://github.com/settings/tokens/new"&gt;clicking here&lt;/a&gt;. I added all of the &lt;code&gt;repo&lt;/code&gt; permissions to the token.&lt;/li&gt;
&lt;li&gt;In VSO, add arguments for the script, replacing &lt;code&gt;TOKEN&lt;/code&gt; with your token and replacing the other values as appropriate:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;-Token TOKEN -UserName &amp;quot;ReubenBond&amp;quot; -Repository &amp;quot;ReubenBond/reubenbond.github.io&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start="10"&gt;
&lt;li&gt;Up on the &lt;em&gt;Triggers&lt;/em&gt; pane, enable Continuous Integration.&lt;/li&gt;
&lt;li&gt;Click &lt;em&gt;Save &amp;amp; queue&lt;/em&gt;, then cross your fingers.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hopefully that's it and you can now add new blog posts to the &lt;code&gt;input/posts&lt;/code&gt; directory.&lt;/p&gt;
</content>
		<summary>&lt;p&gt;Here goes nothing! This blog is built with &lt;a href="https://twitter.com/daveaglick"&gt;Dave Glick's&lt;/a&gt; &lt;a href="https://wyam.io/"&gt;Wyam&lt;/a&gt; static site generator and deployed from a git repo in Visual Studio Online to GitHub Pages. Here's how to set up something similar.&lt;/p&gt;</summary>
	</entry>
</feed>